<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>恶意</title>
    <link>https://kindf.github.io/</link>
    <description>Recent content on 恶意</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 Dec 2019 21:24:14 +0800</lastBuildDate>
    
	<atom:link href="https://kindf.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>进程通信方式</title>
      <link>https://kindf.github.io/post/process_communication_mode/</link>
      <pubDate>Thu, 12 Dec 2019 21:24:14 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/process_communication_mode/</guid>
      <description>IPC对象是活动在内核级别的一种进程间通信的工具（管道，信号量，共享内存等) 1、管道(内核管理的一个缓冲区)：  匿名管道：通常用于父子进程的通信(通过fork复制父进程的信息，关闭父进程的读（或写）通道和子进程的写（或读）通道从而形成单向通信的通道)
  有名管道：通常用于无亲缘关系进程间的通信
  四种读写情况：
   （1）读端不读（fd[0]未关闭），写端一直写 ：直到管道写满数据后，再次write会导致阻塞，直到管道有空位置才写去数据并返回
    （2）写端不写（fd[1]未关闭），但是读端一直读（写端不关闭）：管道为空时阻塞读端，直到管道有数据时才读数据并返回（是否阻塞取决于写端计数器是否大于0&amp;hellip;.）
    （3）读端一直读，且fd[0]保持打开，而写端写了一部分数据不写了，并且关闭fd[1]：读取管道所有数据后返回0
    （4）读端读了一部分数据，不读了且关闭fd[0]，写端一直在写且f[1]还保持打开状态：一旦读端关闭而进程write时会接受信号SIGPIPE，通常导致进程异常终止
   局限性：
   （1）只支持单向数据流
    （2）缓冲区有限，管道只存在于主存中
    （3）所传送的是无格式字节流
    （4）效率低下（写数据需要读端读取后才返回）
    （5）需要注意同步问题？(自带有同步机制)
    （6）有名管道：长期存于系统中，使用不当容易出错
  2、消息队列：  实际上就是信息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
  信息的传递经过四次信息复制：写端-&amp;gt;内核 内核-&amp;gt;读端(消息队列中信息的复制需要额外消耗CPU的时间．不适宜于信息量大或操作频繁的场合)</description>
    </item>
    
    <item>
      <title>git基本操作</title>
      <link>https://kindf.github.io/post/git_operation/</link>
      <pubDate>Tue, 10 Dec 2019 22:39:34 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/git_operation/</guid>
      <description>git add --all
git add 文件名
git commit -m “备注”
git log
git log –pretty=oneline
git status
git diff 文件名
git reset --hard HEAD^
git reset --hard HEAD~100
git reset --hard 版本号
git checkout -- 文件名 &amp;ndash;把文件在工作区做的修改全部撤销
git checkout -- 文件名:把文件在工作区的修改全部撤销，这里有两种情况：
 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
  一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
 git reset HEAD 可以把暂存区的修改撤销掉（unstage），重新放回工作区
理解工作区与暂存区的区别？
工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。 版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。
我们前面说过使用Git提交文件到版本库有两步：
第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。
第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。
菜鸟教程git教程(https://www.runoob.com/git/git-basic-operations.html)
廖雪峰老师的git教程(https://www.liaoxuefeng.com/wiki/896043488029600)</description>
    </item>
    
    <item>
      <title>五种io模型</title>
      <link>https://kindf.github.io/post/io_model/</link>
      <pubDate>Mon, 09 Dec 2019 22:47:37 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/io_model/</guid>
      <description>一、阻塞IO（blocking I/O） 1、io两个阶段：
 1）等待数据准备
  2）将数据从内核拷贝到进程中
 2、调用recvfrom后调用进程/线程阻塞直到内核把数据准备好并把数据拷贝到用户内存后，内核返回结果，调用进程/线程的阻塞状态解除，继续运行（阻塞io）
3、实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的
二、非阻塞IO（noblocking I/O） 1、调用recvfrom后直接返回结果，若内核数据并没有准备好则返回error。
2、在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有（这种方法会导致cpu占用率大幅上升）
3、与阻塞io的主要差异是调用接口后立即返回调用结果而不是阻塞调用方直到内核返回结果。
4、Linux下，可以通过设置socket使其变为non-blocking
三、多路复用IO（IO multiplexing） 1、select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程
2、 当用户进程调用了select，process会阻塞在select上而不是单个io操作上，而同时，kernel会“监视”所有select负责的socket，当任何一个socket的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。
四、异步IO（Asynchronous I/O） 1、用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。
2、真正的异步io（全过程并没有被阻塞，其他四种可能阻塞在数据准备阶段或者数据复制阶段）。
信号驱动IO（signal driven I/O， SIGIO） 1、首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它来读取数据报。无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了select的阻塞与轮询，当有活跃套接字时，由注册的handler处理。
2、阻塞在数据复制阶段。</description>
    </item>
    
    <item>
      <title>期望</title>
      <link>https://kindf.github.io/post/myblog/</link>
      <pubDate>Sun, 08 Dec 2019 21:18:51 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/myblog/</guid>
      <description>2019/12/08 坚持学习，不忘初心 </description>
    </item>
    
  </channel>
</rss>