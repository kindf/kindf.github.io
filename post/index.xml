<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 恶意</title>
    <link>https://kindf.github.io/post/</link>
    <description>Recent content in Posts on 恶意</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Jan 2020 13:06:41 +0800</lastBuildDate>
    
	<atom:link href="https://kindf.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux_operation</title>
      <link>https://kindf.github.io/post/linux_operation/</link>
      <pubDate>Wed, 01 Jan 2020 13:06:41 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/linux_operation/</guid>
      <description>linux基本操作  man(manual缩写):联机手册内容
 man name
man section name(制定章节编号):section参数:1(命令),2(系统调用),3(库函数),5(配置文件)
man -k regexp:列出关键字与正则表达式regexp匹配的手册项目目录
   bc(计算器)
 bc -l:缺省精度为小数点20位
   who:确定有谁在系统中
 可以打印出当前终端的设备文件名
who a i:可以列出当前终端上的登录用户
whoami:仅列出当前终端上的登录
   uptime:已开机时间(系统年龄)
  top:列出资源占用排名靠前的进程
 VIRT:进程逻辑地址空间大小(virtual),观察是否内存泄露
RES:驻留内存数(resident),也就是占用物理内存数
SHR:与其他进程共享的内存数(share)
%CPU:占用CPU百分比
%MEM:占用内存百分比
TIME+:占用的CPU时间
   ps(process status):查阅进程状态
 无选项:只列出在当前终端上启动的进程
e选项:列出系统中所有的进程(进程范围)
f选项:以full格式列出每一个进程(控制列的数目)
l选项:以long格式列出每一个进程(控制列的数目)
命令ps列出的进程属性
 UID:用户ID(注册名)
PID:进程ID PPID:父进程的PID
C:CPU占用指数:最近一段时间(秒级别)进程占用CPU情况
STIME:启动时间
SZ:进程逻辑内存大小(size)
TTY:终端的名字
COMMAND/CMD:命令名
WCHAN:进程在内核的何处睡眠(Wait Channel)
TIME:累计执行时间(占用的CPU时间)
S:状态,S(Sleep), R(Run), Z(Zombie)
   文本文件  重定向机制</description>
    </item>
    
    <item>
      <title>makefile学习</title>
      <link>https://kindf.github.io/post/makefile_learn/</link>
      <pubDate>Fri, 27 Dec 2019 22:29:05 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/makefile_learn/</guid>
      <description>编译时，编译器只检测程序语法和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但能生成object file
链接时，链接器会在所有object file中寻找函数的实现，如找不到就会报链接错误码（Linker Error）
自动推导：只要make看到一个.o文件就会自动把.c文件加到依赖关系中，并且cc -c &amp;hellip;.c也会被推导出来
.PHONY:clean .PHONY表示clean是个伪目标文件
include &amp;lt;filename&amp;gt; filename可以是当前操作系统shell的文件模式（可以包含路径和通配符），include前面不能以tab键开始
 include查找路径（若没指定路径）:
   1、如果make执行时，有“-I”或“&amp;ndash;inlcude-dir”参数，make会在该参数所指定的目录下寻找
    2、如果目录&amp;lt;prefix&amp;gt;/include（一般是：/usr/local/bin 或/usr/include）存在的话，make 也会去找
    -include /&amp;lt;filename&amp;gt;表示无论include过程中出现什么错误都不要报错继续执行
  GUN的make工作时的执行步骤：  1、读入所有的 Makefile。
  2、读入被 include 的其它 Makefile。
  3、初始化文件中的变量。
  4、推导隐晦规则，并分析所有规则。
  5、为所有的目标文件创建依赖关系链。
  6、根据依赖关系，决定哪些目标要重新生成。
  7、执行生成命令。
 文件搜索  VPATH特殊变量:如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make 就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。
 例：VPATH = src:../headers（先在当前目录搜索，然后是src目录和../headers目录
   vpath关键字（全小写）：</description>
    </item>
    
    <item>
      <title>Try</title>
      <link>https://kindf.github.io/post/try/</link>
      <pubDate>Mon, 16 Dec 2019 23:02:11 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/try/</guid>
      <description>  This is my first paragraph.
  点击查看详细内容  int main() { for(int i = 0; i   </description>
    </item>
    
    <item>
      <title>《TCP/IP网络编程》读书笔记</title>
      <link>https://kindf.github.io/post/study_note_of_tcp_ip/</link>
      <pubDate>Mon, 16 Dec 2019 22:31:01 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/study_note_of_tcp_ip/</guid>
      <description>产生僵尸进程的原因 子进程exit或return后操作系统并不会销毁进程，需要主进程做相关的处理，否则就会成为僵尸进程 ps后进程状态stat为Z+即为僵尸进程 调用fork()产生的子进程复制了父进程的文件描述符(并没有复制套接字),这意味着一个套接字可以对应多个文件描述符
select性能不好的两个原因 1.调用select后常见的针对所有文件描述符对象的循环语句 2.(主要)每次调用select时需要传递的监视对象信息(应用程序向操作系统传递数据将对程序造成很大负担且无法通过优化代码解决) 文件描述符(文件句柄):呼应操作系统创建的文件或者套接字的代号
int socket(int domin, int type, int protocol)参数说明: 
domin:套接字的协议族(PF_INET-ipv4协议族, PF_INET6-ipv6协议族) type:套接字的传输方式(SOCK_STREAM-面向连接的数据传输方式, SOCK_DGRAM-面向消息的数据传输方式) protocol:决定最终采用的协议(同一协议族中存在多个传输方式相同的协议,故需要该参数决定采用的协议),但大部分情况下可以通过前两个参数即可创建所需的套接字 满足PF_INET,SOCK_STREAM的协议只有IPPROTO_TCP协议(故可以传0) 满足PF_INET,SOCK_DGRAM的协议只有IPPROTO_UDP协议(故可以传0) 
关于套接字缓冲区: 调用send接口实际上是将数据复制到发送缓冲区中,内核实际上是按照最大MSS大小从缓冲区发送数据的,发送的数据知道被对端确认才从缓冲区中删除 socket地址结构体:  struct sockaddr_in { sa_family_t sin_family; //地址族(AF_INET-ipv4使用的地址族,AF_INET6-ipv6使用的地址族) uint16_t sin_port; //16位TCP/UDP端口号(以网络字节序保存) struct in_addr sin_addr; //32位IP地址(以网络字节序保存) char sin_zero[8]; //不使用 }; struct in_addr { In_addr_t s_addr; //32位Ipv4地址 }; unsigned short htons(unsinged short); //用于端口号转换 unsigned short ntohs(unsinged short); //用于端口号转换 unsigned long htonl(unsigned long); //用于ip地址转换 unsigned long ntohl(usigned long); //用于ip地址转换   socket编程相关API  #include &amp;ltsys/socket.</description>
    </item>
    
    <item>
      <title>进程通信方式</title>
      <link>https://kindf.github.io/post/process_communication_mode/</link>
      <pubDate>Thu, 12 Dec 2019 21:24:14 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/process_communication_mode/</guid>
      <description>IPC对象是活动在内核级别的一种进程间通信的工具（管道，信号量，共享内存等) 1、管道(内核管理的一个缓冲区)：  匿名管道：通常用于父子进程的通信(通过fork复制父进程的信息，关闭父进程的读（或写）通道和子进程的写（或读）通道从而形成单向通信的通道)
  有名管道：通常用于无亲缘关系进程间的通信
  四种读写情况：
   （1）读端不读（fd[0]未关闭），写端一直写 ：直到管道写满数据后，再次write会导致阻塞，直到管道有空位置才写去数据并返回
    （2）写端不写（fd[1]未关闭），但是读端一直读（写端不关闭）：管道为空时阻塞读端，直到管道有数据时才读数据并返回（是否阻塞取决于写端计数器是否大于0&amp;hellip;.）
    （3）读端一直读，且fd[0]保持打开，而写端写了一部分数据不写了，并且关闭fd[1]：读取管道所有数据后返回0
    （4）读端读了一部分数据，不读了且关闭fd[0]，写端一直在写且f[1]还保持打开状态：一旦读端关闭而进程write时会接受信号SIGPIPE，通常导致进程异常终止
   局限性：
   （1）只支持单向数据流
    （2）缓冲区有限，管道只存在于主存中
    （3）所传送的是无格式字节流
    （4）效率低下（写数据需要读端读取后才返回）
    （5）需要注意同步问题？(自带有同步机制)
    （6）有名管道：长期存于系统中，使用不当容易出错
  2、消息队列：  实际上就是信息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
  信息的传递经过四次信息复制：写端-&amp;gt;内核 内核-&amp;gt;读端(消息队列中信息的复制需要额外消耗CPU的时间．不适宜于信息量大或操作频繁的场合)</description>
    </item>
    
    <item>
      <title>git基本操作</title>
      <link>https://kindf.github.io/post/git_operation/</link>
      <pubDate>Tue, 10 Dec 2019 22:39:34 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/git_operation/</guid>
      <description>git配置相关  配置全局账户 git config &amp;ndash;global user.name &amp;ldquo;名称&amp;rdquo;
git config &amp;ndash;global user.email &amp;ldquo;邮箱&amp;rdquo;
   配置局部账户
 git config &amp;ndash;local user.name &amp;ldquo;名称&amp;rdquo;
gir config &amp;ndash;local user.email &amp;ldquo;邮箱&amp;rdquo;
   查看配置
 git config &amp;ndash;global &amp;ndash;list
git config &amp;ndash;local -list
  git本地基本操作  本地变更添加到暂存区
 git add &amp;ndash;all
git add 文件名1 文件名2 &amp;hellip;
   比较差异
 git diff 文件名 (某文件工作区与暂存区差异)
git diff &amp;ndash;cache 文件名 (某文件暂存区与HEAD差异)
git diff (工作区与暂存区差异)</description>
    </item>
    
    <item>
      <title>五种io模型</title>
      <link>https://kindf.github.io/post/io_model/</link>
      <pubDate>Mon, 09 Dec 2019 22:47:37 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/io_model/</guid>
      <description>一、阻塞IO（blocking I/O） 1、io两个阶段：
 1）等待数据准备
  2）将数据从内核拷贝到进程中
 2、调用recvfrom后调用进程/线程阻塞直到内核把数据准备好并把数据拷贝到用户内存后，内核返回结果，调用进程/线程的阻塞状态解除，继续运行（阻塞io）
3、实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的
二、非阻塞IO（noblocking I/O） 1、调用recvfrom后直接返回结果，若内核数据并没有准备好则返回error。
2、在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有（这种方法会导致cpu占用率大幅上升）
3、与阻塞io的主要差异是调用接口后立即返回调用结果而不是阻塞调用方直到内核返回结果。
4、Linux下，可以通过设置socket使其变为non-blocking
三、多路复用IO（IO multiplexing） 1、select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程
2、 当用户进程调用了select，process会阻塞在select上而不是单个io操作上，而同时，kernel会“监视”所有select负责的socket，当任何一个socket的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。
四、异步IO（Asynchronous I/O） 1、用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。
2、真正的异步io（全过程并没有被阻塞，其他四种可能阻塞在数据准备阶段或者数据复制阶段）。
信号驱动IO（signal driven I/O， SIGIO） 1、首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它来读取数据报。无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了select的阻塞与轮询，当有活跃套接字时，由注册的handler处理。
2、阻塞在数据复制阶段。</description>
    </item>
    
    <item>
      <title>期望</title>
      <link>https://kindf.github.io/post/myblog/</link>
      <pubDate>Sun, 08 Dec 2019 21:18:51 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/myblog/</guid>
      <description>2019/12/08 坚持学习，不忘初心 </description>
    </item>
    
  </channel>
</rss>