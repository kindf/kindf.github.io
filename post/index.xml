<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 恶意</title>
    <link>https://kindf.github.io/post/</link>
    <description>Recent content in Posts on 恶意</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 10 Dec 2019 22:39:34 +0800</lastBuildDate>
    
	<atom:link href="https://kindf.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>git基本操作</title>
      <link>https://kindf.github.io/post/git_operation/</link>
      <pubDate>Tue, 10 Dec 2019 22:39:34 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/git_operation/</guid>
      <description>git add --all
git add 文件名
git commit -m “备注”
git log
git log –pretty=oneline
git status
git diff 文件名
git reset --hard HEAD^
git reset --hard HEAD~100
git reset --hard 版本号
git checkout -- 文件名 &amp;ndash;把文件在工作区做的修改全部撤销
git checkout -- 文件名:把文件在工作区的修改全部撤销，这里有两种情况：
 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
  一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
 git reset HEAD 可以把暂存区的修改撤销掉（unstage），重新放回工作区
理解工作区与暂存区的区别？
工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。 版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。
我们前面说过使用Git提交文件到版本库有两步：
第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。
第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。
菜鸟教程git教程(https://www.runoob.com/git/git-basic-operations.html)
廖雪峰老师的git教程(https://www.liaoxuefeng.com/wiki/896043488029600)</description>
    </item>
    
    <item>
      <title>五种io模型</title>
      <link>https://kindf.github.io/post/io_model/</link>
      <pubDate>Mon, 09 Dec 2019 22:47:37 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/io_model/</guid>
      <description>一、阻塞IO（blocking I/O） 1、io两个阶段：
 1）等待数据准备
  2）将数据从内核拷贝到进程中
 2、调用recvfrom后调用进程/线程阻塞直到内核把数据准备好并把数据拷贝到用户内存后，内核返回结果，调用进程/线程的阻塞状态解除，继续运行（阻塞io）
3、实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的
二、非阻塞IO（noblocking I/O） 1、调用recvfrom后直接返回结果，若内核数据并没有准备好则返回error。
2、在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有（这种方法会导致cpu占用率大幅上升）
3、与阻塞io的主要差异是调用接口后立即返回调用结果而不是阻塞调用方直到内核返回结果。
4、Linux下，可以通过设置socket使其变为non-blocking
三、多路复用IO（IO multiplexing） 1、select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程
2、 当用户进程调用了select，process会阻塞在select上而不是单个io操作上，而同时，kernel会“监视”所有select负责的socket，当任何一个socket的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。
四、异步IO（Asynchronous I/O） 1、用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。
2、真正的异步io（全过程并没有被阻塞，其他四种可能阻塞在数据准备阶段或者数据复制阶段）。
信号驱动IO（signal driven I/O， SIGIO） 1、首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它来读取数据报。无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了select的阻塞与轮询，当有活跃套接字时，由注册的handler处理。
2、阻塞在数据复制阶段。</description>
    </item>
    
    <item>
      <title>期望</title>
      <link>https://kindf.github.io/post/myblog/</link>
      <pubDate>Sun, 08 Dec 2019 21:18:51 +0800</pubDate>
      
      <guid>https://kindf.github.io/post/myblog/</guid>
      <description>2019/12/08 坚持学习，不忘初心 </description>
    </item>
    
  </channel>
</rss>