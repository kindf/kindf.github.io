<!doctype html>
<html lang="en-us">
  <head>
    <title>io复用--epoll // 恶意</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.60.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="kindf" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https:kindf.github.io/css/main.min.61bb32028587f24ca28522d8d197970c7ef33284e5fffb45a75fcbbb2dbc4dcb.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="io复用--epoll"/>
<meta name="twitter:description" content="epoll原理   用户态调用epoll_create时,内核会创建一个eventepoll对象(即返回文件描述符所代表的对象)   1.eventpoll较重要的字段:wq(用于保存有哪些进程在等待这个epoll返回)
2.eventpoll较重要的字段:rdllist(用于保存可读写的文件)
3.eventpoll较重要的字段:rbr(用于建立一个快速查找文件句柄的红黑树)
    调用epoll_ctl添加文件描述符   1.内核会把被监听的文件描述符添加到eventepoll结构所维护的红黑树中(描述符就绪时能快速查找)
2.内核会把epitem结构(即该eventepoll对象)添加到被监听文件描述符的等待队列中
3.资源就绪时,中断程序会唤醒相应的eventepoll对象
4.当等待队列被唤醒的时候,将调用ep_poll_callback()函数(把代表该文件描述符的epitem结构放置到eventpoll结构的rdllist队列中并唤醒进程)
    调用epoll_wait()函数开始监听文件   1.内核把当前进程设置为可中断睡眠状态
2.然后把进程添加到eventpoll结构的等待队列中，最后调用schedule_timeout()让出CPU
3.当进程被唤醒时,会判断eventpoll结构的rdllist队列是否为空
  水平触发(LT)与边缘触发(ET)   边缘触发(ET)   1.句柄在发生读写事件时只会通知用户一次
2.ET模式主要关注fd从不可用到可用或者可用到不可用的情况
3.ET只支持非阻塞模式
缺点：应用层业务逻辑复杂，容易遗漏事件，很难用好
优点：相对LT模式效率比较高
    水平触发(LT)   1.只要句柄一直处于可用状态，就会一直通知用户
2.LT模式下，句柄读缓冲区被读空后，句柄会从可用转变未不可以用，这个时候不会通知用户,写缓冲区只要还没写满，就会一直通知用户
3. LT模式支持阻塞和非阻塞两种方式,epoll默认的模式是LT
优点：编程更符合用户直觉，业务层逻辑更简单
缺点：效率比ET低
  epoll相关API  struct epoll_event { __uint32_t events; epoll_data_t data: } typedef union epoll_data { void *ptr; inf fd; __uint32_t u32; __unit64_t u64; } epoll_data_t; #include &lt;sys/epoll."/>

    <meta property="og:title" content="io复用--epoll" />
<meta property="og:description" content="epoll原理   用户态调用epoll_create时,内核会创建一个eventepoll对象(即返回文件描述符所代表的对象)   1.eventpoll较重要的字段:wq(用于保存有哪些进程在等待这个epoll返回)
2.eventpoll较重要的字段:rdllist(用于保存可读写的文件)
3.eventpoll较重要的字段:rbr(用于建立一个快速查找文件句柄的红黑树)
    调用epoll_ctl添加文件描述符   1.内核会把被监听的文件描述符添加到eventepoll结构所维护的红黑树中(描述符就绪时能快速查找)
2.内核会把epitem结构(即该eventepoll对象)添加到被监听文件描述符的等待队列中
3.资源就绪时,中断程序会唤醒相应的eventepoll对象
4.当等待队列被唤醒的时候,将调用ep_poll_callback()函数(把代表该文件描述符的epitem结构放置到eventpoll结构的rdllist队列中并唤醒进程)
    调用epoll_wait()函数开始监听文件   1.内核把当前进程设置为可中断睡眠状态
2.然后把进程添加到eventpoll结构的等待队列中，最后调用schedule_timeout()让出CPU
3.当进程被唤醒时,会判断eventpoll结构的rdllist队列是否为空
  水平触发(LT)与边缘触发(ET)   边缘触发(ET)   1.句柄在发生读写事件时只会通知用户一次
2.ET模式主要关注fd从不可用到可用或者可用到不可用的情况
3.ET只支持非阻塞模式
缺点：应用层业务逻辑复杂，容易遗漏事件，很难用好
优点：相对LT模式效率比较高
    水平触发(LT)   1.只要句柄一直处于可用状态，就会一直通知用户
2.LT模式下，句柄读缓冲区被读空后，句柄会从可用转变未不可以用，这个时候不会通知用户,写缓冲区只要还没写满，就会一直通知用户
3. LT模式支持阻塞和非阻塞两种方式,epoll默认的模式是LT
优点：编程更符合用户直觉，业务层逻辑更简单
缺点：效率比ET低
  epoll相关API  struct epoll_event { __uint32_t events; epoll_data_t data: } typedef union epoll_data { void *ptr; inf fd; __uint32_t u32; __unit64_t u64; } epoll_data_t; #include &lt;sys/epoll." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https:kindf.github.io/post/epoll/" />
<meta property="article:published_time" content="2020-01-10T21:15:11+08:00" />
<meta property="article:modified_time" content="2020-01-10T21:15:11+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https:kindf.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="kindf" /></a>
      <h1>恶意</h1>
      <p>学习笔记</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://www.github.com/kindf" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://www.baidu.com" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-link">
  <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
  <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">io复用--epoll</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jan 10, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <blockquote>
<h4 id="epoll">epoll原理</h4>
<ul>
<li>
<h5 id="epollcreateeventepoll">用户态调用epoll_create时,内核会创建一个eventepoll对象(即返回文件描述符所代表的对象)</h5>
</li>
</ul>
<p>1.eventpoll较重要的字段:wq(用于保存有哪些进程在等待这个epoll返回)<br>
2.eventpoll较重要的字段:rdllist(用于保存可读写的文件)<br>
3.eventpoll较重要的字段:rbr(用于建立一个快速查找文件句柄的红黑树)</p>
</blockquote>
<blockquote>
<ul>
<li>
<h5 id="epollctl">调用epoll_ctl添加文件描述符</h5>
</li>
</ul>
<p>1.内核会把被监听的文件描述符添加到eventepoll结构所维护的红黑树中(描述符就绪时能快速查找)<br>
2.内核会把epitem结构(即该eventepoll对象)添加到被监听文件描述符的等待队列中<br>
3.资源就绪时,中断程序会唤醒相应的eventepoll对象<br>
4.当等待队列被唤醒的时候,将调用ep_poll_callback()函数(把代表该文件描述符的epitem结构放置到eventpoll结构的rdllist队列中并唤醒进程)</p>
</blockquote>
<blockquote>
<ul>
<li>
<h5 id="epollwait">调用epoll_wait()函数开始监听文件</h5>
</li>
</ul>
<p>1.内核把当前进程设置为可中断睡眠状态<br>
2.然后把进程添加到eventpoll结构的等待队列中，最后调用schedule_timeout()让出CPU<br>
3.当进程被唤醒时,会判断eventpoll结构的rdllist队列是否为空</p>
</blockquote>
<blockquote>
<h4 id="ltet">水平触发(LT)与边缘触发(ET)</h4>
<ul>
<li>
<h5 id="et">边缘触发(ET)</h5>
</li>
</ul>
<p>1.句柄在发生读写事件时只会通知用户一次<br>
2.ET模式主要关注fd从不可用到可用或者可用到不可用的情况<br>
3.ET只支持非阻塞模式<br>
缺点：应用层业务逻辑复杂，容易遗漏事件，很难用好<br>
优点：相对LT模式效率比较高</p>
</blockquote>
<blockquote>
<ul>
<li>
<h5 id="lt">水平触发(LT)</h5>
</li>
</ul>
<p>1.只要句柄一直处于可用状态，就会一直通知用户<br>
2.LT模式下，句柄读缓冲区被读空后，句柄会从可用转变未不可以用，这个时候不会通知用户,写缓冲区只要还没写满，就会一直通知用户<br>
3.
LT模式支持阻塞和非阻塞两种方式,epoll默认的模式是LT<br>
优点：编程更符合用户直觉，业务层逻辑更简单<br>
缺点：效率比ET低</p>
</blockquote>
<blockquote>
<h4 id="epollapi">epoll相关API</h4>
</blockquote>
<pre><code>struct epoll_event
{
	__uint32_t events;
	epoll_data_t data:
}

typedef union epoll_data
{
	void *ptr;
	inf fd;
	__uint32_t u32;
	__unit64_t u64;
} epoll_data_t;

#include &lt;sys/epoll.h&gt;
int epoll_create(int size);
//成功时返回epoll文件描述符,失败时返回-1
//size:仅用于参考

#include &lt;sys/epoll.h&gt;
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
//成功时返回0,失败时返回-1
//epfd:用于注册监视对象epoll例程的文件描述符
//op:用于指定监视对象的添加、删除或更改等操作
//fd:需要注册的监视对象文件描述符
//event:监视对象的事件类型

第二个参数:
EPOLL_CTL_ADD:将文件描述符注册到epoll例程
EPOLL_CTL_DEL:从epoll例程中删除文件描述符
EPOLL_CTL_MOD:更改注册的文件描述符所关注事件发生情况

第三个参数中的events;变量:
EPOLLIN:需要读取数据的情况
EPOLLOUT:输出缓冲区为空,可以立即发送数据的情况
EPOLLPRI:收到OOB数据的情况
EPOLLRDHUP:断开连接或者半关闭的情况,这在边缘触发方式下非常有用
EPOLLERR:发生错误的情况
EPOLLET:以边缘触发的方式得到事件通知
EPOLLON:发生一次事件后,相应文件描述符不再收到时间通知.因此需要向epoll_ctl函数的第二个参数传递EPOLL_CTL_MOD再次设置事件

#include &lt;sys/epoll.h&gt;
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
//成功时返回发生时间的文件描述符数,失败时返回-1
//epfd:表示事件发生监视范围的epoll例程的文件描述符
//events 保存发生事件的文件描述符集合的结构体地址值
//maxevnets 第二个参数中可以保存的最大时间数
//timeout 以1/1000秒问单位的等待时间,传递-1表示一直等待直到事件发生
</code></pre>
    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
