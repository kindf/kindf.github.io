[{"categories":["skynet相关"],"content":"\r主要结构 17 #define TIME_NEAR_SHIFT 8 18 #define TIME_NEAR (1 \u003c\u003c TIME_NEAR_SHIFT) 19 #define TIME_LEVEL_SHIFT 6 20 #define TIME_LEVEL (1 \u003c\u003c TIME_LEVEL_SHIFT) 21 #define TIME_NEAR_MASK (TIME_NEAR-1) 22 #define TIME_LEVEL_MASK (TIME_LEVEL-1) 23 24 struct timer_event { 25 \u003e uint32_t handle; 26 \u003e int session; 27 }; 28 29 struct timer_node { 30 \u003e struct timer_node *next; 31 \u003e uint32_t expire; 32 }; 33 34 struct link_list { 35 \u003e struct timer_node head; 36 \u003e struct timer_node *tail; 37 }; 38 39 struct timer { 40 \u003e struct link_list near[TIME_NEAR]; //到期时间较近定时器事件链表 41 \u003e struct link_list t[4][TIME_LEVEL]; //定时器事件链表 42 \u003e struct spinlock lock; //自旋锁 43 \u003e uint32_t time; //启动后tick的时间 44 \u003e uint32_t starttime; //启动时的系统时间 45 \u003e uint64_t current; //skynet自己计算出的实际时间 46 \u003e uint64_t current_point; // 47 }; skynet定时器的基本思想就是把到期时间较近的事件放到near数组中，其余的放到t数值中，每次tick后就从near数组中找到到期的事件触发 定时事件插入 67 static void 68 add_node(struct timer *T,struct timer_node *node) { 69 \u003e uint32_t time=node-\u003eexpire; 70 \u003e uint32_t current_time=T-\u003etime; 71 \u003e 72 \u003e if ((time|TIME_NEAR_MASK)==(current_time|TIME_NEAR_MASK)) { 73 \u003e \u003e link(\u0026T-\u003enear[time\u0026TIME_NEAR_MASK],node); 74 \u003e } else { 75 \u003e \u003e int i; 76 \u003e \u003e uint32_t mask=TIME_NEAR \u003c\u003c TIME_LEVEL_SHIFT; 77 \u003e \u003e for (i=0;i\u003c3;i++) { 78 \u003e \u003e \u003e if ((time|(mask-1))==(current_time|(mask-1))) { 79 \u003e \u003e \u003e \u003e break; 80 \u003e \u003e \u003e } 81 \u003e \u003e \u003e mask \u003c\u003c= TIME_LEVEL_SHIFT; 82 \u003e \u003e } 83 84 \u003e \u003e link(\u0026T-\u003et[i][((time\u003e\u003e(TIME_NEAR_SHIFT + i*TIME_LEVEL_SHIFT)) \u0026 TIME_LEVEL_MASK)],node);\u003e 85 \u003e } 86 } add_node函数可以看出定时事件是怎么分布到near和t数组的 time可以理解为到期时间，current_time可以理解为现在的时间 这里假设 ​ current_time二进制表示为 100000 | 010000 | 001000 | 000100 | 00000010 ​ t1二进制表示为 100000 | 010000 | 001000 | 000100 | 00000011 ​ t2二进制表示为 100000 | 010000 | 001000 | 000101 | 00000010 ​ t3二进制表示为 100000 | 010000 | 001001 | 000100 | 00000010 ​ t4二进制表示为 100000 | 010001 | 001000 | 000100 | 00000010 ​ t5二进制表示为 100001 | 010000 | 001000 | 000100 | 00000010 72 ~ 73： ​ 将time和current_time第9~32位都相同的事件放到near[x]，x是time的第1~8位表示的数值（当time=t1时，t1放到near[3]中，因为t1第1~8位 00000011即为3） 76 ~ 82： ​ 将time和current_time第15~32相同，但第9~14位不相同的到期事件放到t[0][x]数组中，x是time的第9~14位表示的数值（当time=t2时，t2放到t[0][5]，因为t2第9~14位 000101 即为5） ​ 将time和current_time第21~32相同，但第15~20位不相同的到期事件放到t[1][x]数组中，x是time的第15~20位表示的数值（当time=t3时，t3放到t[0][9]，因为t2第9~14位 001001 即为9） ​ 将time和current_time第27~32相同，但第21~26位不相同的到期事件放到t[2][x]数组中，x是time的第21~26位表示的数值（当time=t4时，t4放到t[0][17]，因为t2第9~14位 010001 即为17） ​ 将time和current_time27~32位不相同的到期事件放到t[3][x]数组中，x是time的第27~32位表示的数值（当time=t5时，t5放到t[0][33]，因为t2第9~14位 100001 即为33） 大致上看当current_time为100000 | 010000 | 001000 | 000100 | xxxxxxxx时： ​ 100000 | 010000 | 001000 | 000100 | xxxxxxxx 放到 near中 ​ 100000 | 010000 | 001000 | xxxxxx | xxxxxxxx 放到t[0]中 ​ 100000 | 010000 | xxxxxx | xxxxxx | xxxxxxxx 放到t[1]中 ​ 100000 | xxxxxx | xxxxxx | xxxxxx | xxxxxxxx 放到t[2]中 ​ xxxxxx| xxxxxx| xxxxxx | xxxxxx | xxxxxxxx 放到t[3]中 需要注意的是，并不是说和current_time接近的time就一定会在near中，因为near只包含第9~32位都相同的情况 ​ 一个比较极端的情况是当current_time为 000000 | 111111 | 111111 | 111111 | 11111111 ​ 此时插入与其相差为1的time（000001 | 000000 | 000000 | 000000 | 00000000），是放在t[3][1]中 定时器执行 152 static inline void 153 timer_execute(struct timer *T) { 154 \u003e int idx = T-\u003etime \u0026 TIME_NEAR_MASK; 155 \u003e 156 \u003e while (T-\u003enear[idx].head.next) { 157 \u003e \u003e struct timer_node *current = link_clear(\u0026T-\u003enear[idx]); 158 \u003e \u003e SPIN_UNLOCK(T); 159 \u003e \u003e // dispatch_list don't need lock T 160 \u003e \u003e dispatch_list(current); 161 \u003e \u003e SPIN_LOCK(T); 162 \u003e } 163 } ​ 因为最近的事件都在near上，只需要根据idx就能找到到期的事件 到期事件再分配 101 static void 102 move_list(struct timer *T, int level, int idx) { 103 \u003e struct timer_node *current = link_clear(\u0026T-\u003et[level][idx]); 104 \u003e while (current) { 105 \u003e \u003e struct timer_node *temp=current-\u003enext; 106 \u003e \u003e add_node(T,current); 107 \u003e \u003e current=temp; 108 \u003e } 109 } 111 static void 112 timer_shift(struct timer *T) { 113 \u003e int mask = TIME_NEAR; 114 \u003e uint32_t ct = ++T-\u003etime; 115 \u003e if (ct == 0) { 116 \u003e \u003e move_list(T, 3, 0); 117 \u003e } else { 118 \u003e \u003e uint32_t time = ct \u003e\u003e TIME_NEAR_SHIFT; 119 \u003e \u003e int i=0; 120 121 \u003e \u003e while ((ct \u0026 (mask-1))==0","date":"2023-11-14","objectID":"/posts/skynet/skynet_timer/:0:0","series":null,"tags":null,"title":"skynet的定时器","uri":"/posts/skynet/skynet_timer/#"},{"categories":["skynet相关"],"content":"\r主要结构 17 #define TIME_NEAR_SHIFT 8 18 #define TIME_NEAR (1 \u003c\u003c TIME_NEAR_SHIFT) 19 #define TIME_LEVEL_SHIFT 6 20 #define TIME_LEVEL (1 \u003c\u003c TIME_LEVEL_SHIFT) 21 #define TIME_NEAR_MASK (TIME_NEAR-1) 22 #define TIME_LEVEL_MASK (TIME_LEVEL-1) 23 24 struct timer_event { 25 \u003e uint32_t handle; 26 \u003e int session; 27 }; 28 29 struct timer_node { 30 \u003e struct timer_node *next; 31 \u003e uint32_t expire; 32 }; 33 34 struct link_list { 35 \u003e struct timer_node head; 36 \u003e struct timer_node *tail; 37 }; 38 39 struct timer { 40 \u003e struct link_list near[TIME_NEAR]; //到期时间较近定时器事件链表 41 \u003e struct link_list t[4][TIME_LEVEL]; //定时器事件链表 42 \u003e struct spinlock lock; //自旋锁 43 \u003e uint32_t time; //启动后tick的时间 44 \u003e uint32_t starttime; //启动时的系统时间 45 \u003e uint64_t current; //skynet自己计算出的实际时间 46 \u003e uint64_t current_point; // 47 }; skynet定时器的基本思想就是把到期时间较近的事件放到near数组中，其余的放到t数值中，每次tick后就从near数组中找到到期的事件触发 定时事件插入 67 static void 68 add_node(struct timer *T,struct timer_node *node) { 69 \u003e uint32_t time=node-\u003eexpire; 70 \u003e uint32_t current_time=T-\u003etime; 71 \u003e 72 \u003e if ((time|TIME_NEAR_MASK)==(current_time|TIME_NEAR_MASK)) { 73 \u003e \u003e link(\u0026T-\u003enear[time\u0026TIME_NEAR_MASK],node); 74 \u003e } else { 75 \u003e \u003e int i; 76 \u003e \u003e uint32_t mask=TIME_NEAR \u003c\u003c TIME_LEVEL_SHIFT; 77 \u003e \u003e for (i=0;i\u003c3;i++) { 78 \u003e \u003e \u003e if ((time|(mask-1))==(current_time|(mask-1))) { 79 \u003e \u003e \u003e \u003e break; 80 \u003e \u003e \u003e } 81 \u003e \u003e \u003e mask \u003c\u003c= TIME_LEVEL_SHIFT; 82 \u003e \u003e } 83 84 \u003e \u003e link(\u0026T-\u003et[i][((time\u003e\u003e(TIME_NEAR_SHIFT + i*TIME_LEVEL_SHIFT)) \u0026 TIME_LEVEL_MASK)],node);\u003e 85 \u003e } 86 } add_node函数可以看出定时事件是怎么分布到near和t数组的 time可以理解为到期时间，current_time可以理解为现在的时间 这里假设 ​ current_time二进制表示为 100000 | 010000 | 001000 | 000100 | 00000010 ​ t1二进制表示为 100000 | 010000 | 001000 | 000100 | 00000011 ​ t2二进制表示为 100000 | 010000 | 001000 | 000101 | 00000010 ​ t3二进制表示为 100000 | 010000 | 001001 | 000100 | 00000010 ​ t4二进制表示为 100000 | 010001 | 001000 | 000100 | 00000010 ​ t5二进制表示为 100001 | 010000 | 001000 | 000100 | 00000010 72 ~ 73： ​ 将time和current_time第9~32位都相同的事件放到near[x]，x是time的第1~8位表示的数值（当time=t1时，t1放到near[3]中，因为t1第1~8位 00000011即为3） 76 ~ 82： ​ 将time和current_time第15~32相同，但第9~14位不相同的到期事件放到t[0][x]数组中，x是time的第9~14位表示的数值（当time=t2时，t2放到t[0][5]，因为t2第9~14位 000101 即为5） ​ 将time和current_time第21~32相同，但第15~20位不相同的到期事件放到t[1][x]数组中，x是time的第15~20位表示的数值（当time=t3时，t3放到t[0][9]，因为t2第9~14位 001001 即为9） ​ 将time和current_time第27~32相同，但第21~26位不相同的到期事件放到t[2][x]数组中，x是time的第21~26位表示的数值（当time=t4时，t4放到t[0][17]，因为t2第9~14位 010001 即为17） ​ 将time和current_time27~32位不相同的到期事件放到t[3][x]数组中，x是time的第27~32位表示的数值（当time=t5时，t5放到t[0][33]，因为t2第9~14位 100001 即为33） 大致上看当current_time为100000 | 010000 | 001000 | 000100 | xxxxxxxx时： ​ 100000 | 010000 | 001000 | 000100 | xxxxxxxx 放到 near中 ​ 100000 | 010000 | 001000 | xxxxxx | xxxxxxxx 放到t[0]中 ​ 100000 | 010000 | xxxxxx | xxxxxx | xxxxxxxx 放到t[1]中 ​ 100000 | xxxxxx | xxxxxx | xxxxxx | xxxxxxxx 放到t[2]中 ​ xxxxxx| xxxxxx| xxxxxx | xxxxxx | xxxxxxxx 放到t[3]中 需要注意的是，并不是说和current_time接近的time就一定会在near中，因为near只包含第9~32位都相同的情况 ​ 一个比较极端的情况是当current_time为 000000 | 111111 | 111111 | 111111 | 11111111 ​ 此时插入与其相差为1的time（000001 | 000000 | 000000 | 000000 | 00000000），是放在t[3][1]中 定时器执行 152 static inline void 153 timer_execute(struct timer *T) { 154 \u003e int idx = T-\u003etime \u0026 TIME_NEAR_MASK; 155 \u003e 156 \u003e while (T-\u003enear[idx].head.next) { 157 \u003e \u003e struct timer_node *current = link_clear(\u0026T-\u003enear[idx]); 158 \u003e \u003e SPIN_UNLOCK(T); 159 \u003e \u003e // dispatch_list don't need lock T 160 \u003e \u003e dispatch_list(current); 161 \u003e \u003e SPIN_LOCK(T); 162 \u003e } 163 } ​ 因为最近的事件都在near上，只需要根据idx就能找到到期的事件 到期事件再分配 101 static void 102 move_list(struct timer *T, int level, int idx) { 103 \u003e struct timer_node *current = link_clear(\u0026T-\u003et[level][idx]); 104 \u003e while (current) { 105 \u003e \u003e struct timer_node *temp=current-\u003enext; 106 \u003e \u003e add_node(T,current); 107 \u003e \u003e current=temp; 108 \u003e } 109 } 111 static void 112 timer_shift(struct timer *T) { 113 \u003e int mask = TIME_NEAR; 114 \u003e uint32_t ct = ++T-\u003etime; 115 \u003e if (ct == 0) { 116 \u003e \u003e move_list(T, 3, 0); 117 \u003e } else { 118 \u003e \u003e uint32_t time = ct \u003e\u003e TIME_NEAR_SHIFT; 119 \u003e \u003e int i=0; 120 121 \u003e \u003e while ((ct \u0026 (mask-1))==0","date":"2023-11-14","objectID":"/posts/skynet/skynet_timer/:0:0","series":null,"tags":null,"title":"skynet的定时器","uri":"/posts/skynet/skynet_timer/#主要结构"},{"categories":["skynet相关"],"content":"\r主要结构 17 #define TIME_NEAR_SHIFT 8 18 #define TIME_NEAR (1 \u003c\u003c TIME_NEAR_SHIFT) 19 #define TIME_LEVEL_SHIFT 6 20 #define TIME_LEVEL (1 \u003c\u003c TIME_LEVEL_SHIFT) 21 #define TIME_NEAR_MASK (TIME_NEAR-1) 22 #define TIME_LEVEL_MASK (TIME_LEVEL-1) 23 24 struct timer_event { 25 \u003e uint32_t handle; 26 \u003e int session; 27 }; 28 29 struct timer_node { 30 \u003e struct timer_node *next; 31 \u003e uint32_t expire; 32 }; 33 34 struct link_list { 35 \u003e struct timer_node head; 36 \u003e struct timer_node *tail; 37 }; 38 39 struct timer { 40 \u003e struct link_list near[TIME_NEAR]; //到期时间较近定时器事件链表 41 \u003e struct link_list t[4][TIME_LEVEL]; //定时器事件链表 42 \u003e struct spinlock lock; //自旋锁 43 \u003e uint32_t time; //启动后tick的时间 44 \u003e uint32_t starttime; //启动时的系统时间 45 \u003e uint64_t current; //skynet自己计算出的实际时间 46 \u003e uint64_t current_point; // 47 }; skynet定时器的基本思想就是把到期时间较近的事件放到near数组中，其余的放到t数值中，每次tick后就从near数组中找到到期的事件触发 定时事件插入 67 static void 68 add_node(struct timer *T,struct timer_node *node) { 69 \u003e uint32_t time=node-\u003eexpire; 70 \u003e uint32_t current_time=T-\u003etime; 71 \u003e 72 \u003e if ((time|TIME_NEAR_MASK)==(current_time|TIME_NEAR_MASK)) { 73 \u003e \u003e link(\u0026T-\u003enear[time\u0026TIME_NEAR_MASK],node); 74 \u003e } else { 75 \u003e \u003e int i; 76 \u003e \u003e uint32_t mask=TIME_NEAR \u003c\u003c TIME_LEVEL_SHIFT; 77 \u003e \u003e for (i=0;i\u003c3;i++) { 78 \u003e \u003e \u003e if ((time|(mask-1))==(current_time|(mask-1))) { 79 \u003e \u003e \u003e \u003e break; 80 \u003e \u003e \u003e } 81 \u003e \u003e \u003e mask \u003c\u003c= TIME_LEVEL_SHIFT; 82 \u003e \u003e } 83 84 \u003e \u003e link(\u0026T-\u003et[i][((time\u003e\u003e(TIME_NEAR_SHIFT + i*TIME_LEVEL_SHIFT)) \u0026 TIME_LEVEL_MASK)],node);\u003e 85 \u003e } 86 } add_node函数可以看出定时事件是怎么分布到near和t数组的 time可以理解为到期时间，current_time可以理解为现在的时间 这里假设 ​ current_time二进制表示为 100000 | 010000 | 001000 | 000100 | 00000010 ​ t1二进制表示为 100000 | 010000 | 001000 | 000100 | 00000011 ​ t2二进制表示为 100000 | 010000 | 001000 | 000101 | 00000010 ​ t3二进制表示为 100000 | 010000 | 001001 | 000100 | 00000010 ​ t4二进制表示为 100000 | 010001 | 001000 | 000100 | 00000010 ​ t5二进制表示为 100001 | 010000 | 001000 | 000100 | 00000010 72 ~ 73： ​ 将time和current_time第9~32位都相同的事件放到near[x]，x是time的第1~8位表示的数值（当time=t1时，t1放到near[3]中，因为t1第1~8位 00000011即为3） 76 ~ 82： ​ 将time和current_time第15~32相同，但第9~14位不相同的到期事件放到t[0][x]数组中，x是time的第9~14位表示的数值（当time=t2时，t2放到t[0][5]，因为t2第9~14位 000101 即为5） ​ 将time和current_time第21~32相同，但第15~20位不相同的到期事件放到t[1][x]数组中，x是time的第15~20位表示的数值（当time=t3时，t3放到t[0][9]，因为t2第9~14位 001001 即为9） ​ 将time和current_time第27~32相同，但第21~26位不相同的到期事件放到t[2][x]数组中，x是time的第21~26位表示的数值（当time=t4时，t4放到t[0][17]，因为t2第9~14位 010001 即为17） ​ 将time和current_time27~32位不相同的到期事件放到t[3][x]数组中，x是time的第27~32位表示的数值（当time=t5时，t5放到t[0][33]，因为t2第9~14位 100001 即为33） 大致上看当current_time为100000 | 010000 | 001000 | 000100 | xxxxxxxx时： ​ 100000 | 010000 | 001000 | 000100 | xxxxxxxx 放到 near中 ​ 100000 | 010000 | 001000 | xxxxxx | xxxxxxxx 放到t[0]中 ​ 100000 | 010000 | xxxxxx | xxxxxx | xxxxxxxx 放到t[1]中 ​ 100000 | xxxxxx | xxxxxx | xxxxxx | xxxxxxxx 放到t[2]中 ​ xxxxxx| xxxxxx| xxxxxx | xxxxxx | xxxxxxxx 放到t[3]中 需要注意的是，并不是说和current_time接近的time就一定会在near中，因为near只包含第9~32位都相同的情况 ​ 一个比较极端的情况是当current_time为 000000 | 111111 | 111111 | 111111 | 11111111 ​ 此时插入与其相差为1的time（000001 | 000000 | 000000 | 000000 | 00000000），是放在t[3][1]中 定时器执行 152 static inline void 153 timer_execute(struct timer *T) { 154 \u003e int idx = T-\u003etime \u0026 TIME_NEAR_MASK; 155 \u003e 156 \u003e while (T-\u003enear[idx].head.next) { 157 \u003e \u003e struct timer_node *current = link_clear(\u0026T-\u003enear[idx]); 158 \u003e \u003e SPIN_UNLOCK(T); 159 \u003e \u003e // dispatch_list don't need lock T 160 \u003e \u003e dispatch_list(current); 161 \u003e \u003e SPIN_LOCK(T); 162 \u003e } 163 } ​ 因为最近的事件都在near上，只需要根据idx就能找到到期的事件 到期事件再分配 101 static void 102 move_list(struct timer *T, int level, int idx) { 103 \u003e struct timer_node *current = link_clear(\u0026T-\u003et[level][idx]); 104 \u003e while (current) { 105 \u003e \u003e struct timer_node *temp=current-\u003enext; 106 \u003e \u003e add_node(T,current); 107 \u003e \u003e current=temp; 108 \u003e } 109 } 111 static void 112 timer_shift(struct timer *T) { 113 \u003e int mask = TIME_NEAR; 114 \u003e uint32_t ct = ++T-\u003etime; 115 \u003e if (ct == 0) { 116 \u003e \u003e move_list(T, 3, 0); 117 \u003e } else { 118 \u003e \u003e uint32_t time = ct \u003e\u003e TIME_NEAR_SHIFT; 119 \u003e \u003e int i=0; 120 121 \u003e \u003e while ((ct \u0026 (mask-1))==0","date":"2023-11-14","objectID":"/posts/skynet/skynet_timer/:0:0","series":null,"tags":null,"title":"skynet的定时器","uri":"/posts/skynet/skynet_timer/#定时事件插入"},{"categories":["skynet相关"],"content":"\r主要结构 17 #define TIME_NEAR_SHIFT 8 18 #define TIME_NEAR (1 \u003c\u003c TIME_NEAR_SHIFT) 19 #define TIME_LEVEL_SHIFT 6 20 #define TIME_LEVEL (1 \u003c\u003c TIME_LEVEL_SHIFT) 21 #define TIME_NEAR_MASK (TIME_NEAR-1) 22 #define TIME_LEVEL_MASK (TIME_LEVEL-1) 23 24 struct timer_event { 25 \u003e uint32_t handle; 26 \u003e int session; 27 }; 28 29 struct timer_node { 30 \u003e struct timer_node *next; 31 \u003e uint32_t expire; 32 }; 33 34 struct link_list { 35 \u003e struct timer_node head; 36 \u003e struct timer_node *tail; 37 }; 38 39 struct timer { 40 \u003e struct link_list near[TIME_NEAR]; //到期时间较近定时器事件链表 41 \u003e struct link_list t[4][TIME_LEVEL]; //定时器事件链表 42 \u003e struct spinlock lock; //自旋锁 43 \u003e uint32_t time; //启动后tick的时间 44 \u003e uint32_t starttime; //启动时的系统时间 45 \u003e uint64_t current; //skynet自己计算出的实际时间 46 \u003e uint64_t current_point; // 47 }; skynet定时器的基本思想就是把到期时间较近的事件放到near数组中，其余的放到t数值中，每次tick后就从near数组中找到到期的事件触发 定时事件插入 67 static void 68 add_node(struct timer *T,struct timer_node *node) { 69 \u003e uint32_t time=node-\u003eexpire; 70 \u003e uint32_t current_time=T-\u003etime; 71 \u003e 72 \u003e if ((time|TIME_NEAR_MASK)==(current_time|TIME_NEAR_MASK)) { 73 \u003e \u003e link(\u0026T-\u003enear[time\u0026TIME_NEAR_MASK],node); 74 \u003e } else { 75 \u003e \u003e int i; 76 \u003e \u003e uint32_t mask=TIME_NEAR \u003c\u003c TIME_LEVEL_SHIFT; 77 \u003e \u003e for (i=0;i\u003c3;i++) { 78 \u003e \u003e \u003e if ((time|(mask-1))==(current_time|(mask-1))) { 79 \u003e \u003e \u003e \u003e break; 80 \u003e \u003e \u003e } 81 \u003e \u003e \u003e mask \u003c\u003c= TIME_LEVEL_SHIFT; 82 \u003e \u003e } 83 84 \u003e \u003e link(\u0026T-\u003et[i][((time\u003e\u003e(TIME_NEAR_SHIFT + i*TIME_LEVEL_SHIFT)) \u0026 TIME_LEVEL_MASK)],node);\u003e 85 \u003e } 86 } add_node函数可以看出定时事件是怎么分布到near和t数组的 time可以理解为到期时间，current_time可以理解为现在的时间 这里假设 ​ current_time二进制表示为 100000 | 010000 | 001000 | 000100 | 00000010 ​ t1二进制表示为 100000 | 010000 | 001000 | 000100 | 00000011 ​ t2二进制表示为 100000 | 010000 | 001000 | 000101 | 00000010 ​ t3二进制表示为 100000 | 010000 | 001001 | 000100 | 00000010 ​ t4二进制表示为 100000 | 010001 | 001000 | 000100 | 00000010 ​ t5二进制表示为 100001 | 010000 | 001000 | 000100 | 00000010 72 ~ 73： ​ 将time和current_time第9~32位都相同的事件放到near[x]，x是time的第1~8位表示的数值（当time=t1时，t1放到near[3]中，因为t1第1~8位 00000011即为3） 76 ~ 82： ​ 将time和current_time第15~32相同，但第9~14位不相同的到期事件放到t[0][x]数组中，x是time的第9~14位表示的数值（当time=t2时，t2放到t[0][5]，因为t2第9~14位 000101 即为5） ​ 将time和current_time第21~32相同，但第15~20位不相同的到期事件放到t[1][x]数组中，x是time的第15~20位表示的数值（当time=t3时，t3放到t[0][9]，因为t2第9~14位 001001 即为9） ​ 将time和current_time第27~32相同，但第21~26位不相同的到期事件放到t[2][x]数组中，x是time的第21~26位表示的数值（当time=t4时，t4放到t[0][17]，因为t2第9~14位 010001 即为17） ​ 将time和current_time27~32位不相同的到期事件放到t[3][x]数组中，x是time的第27~32位表示的数值（当time=t5时，t5放到t[0][33]，因为t2第9~14位 100001 即为33） 大致上看当current_time为100000 | 010000 | 001000 | 000100 | xxxxxxxx时： ​ 100000 | 010000 | 001000 | 000100 | xxxxxxxx 放到 near中 ​ 100000 | 010000 | 001000 | xxxxxx | xxxxxxxx 放到t[0]中 ​ 100000 | 010000 | xxxxxx | xxxxxx | xxxxxxxx 放到t[1]中 ​ 100000 | xxxxxx | xxxxxx | xxxxxx | xxxxxxxx 放到t[2]中 ​ xxxxxx| xxxxxx| xxxxxx | xxxxxx | xxxxxxxx 放到t[3]中 需要注意的是，并不是说和current_time接近的time就一定会在near中，因为near只包含第9~32位都相同的情况 ​ 一个比较极端的情况是当current_time为 000000 | 111111 | 111111 | 111111 | 11111111 ​ 此时插入与其相差为1的time（000001 | 000000 | 000000 | 000000 | 00000000），是放在t[3][1]中 定时器执行 152 static inline void 153 timer_execute(struct timer *T) { 154 \u003e int idx = T-\u003etime \u0026 TIME_NEAR_MASK; 155 \u003e 156 \u003e while (T-\u003enear[idx].head.next) { 157 \u003e \u003e struct timer_node *current = link_clear(\u0026T-\u003enear[idx]); 158 \u003e \u003e SPIN_UNLOCK(T); 159 \u003e \u003e // dispatch_list don't need lock T 160 \u003e \u003e dispatch_list(current); 161 \u003e \u003e SPIN_LOCK(T); 162 \u003e } 163 } ​ 因为最近的事件都在near上，只需要根据idx就能找到到期的事件 到期事件再分配 101 static void 102 move_list(struct timer *T, int level, int idx) { 103 \u003e struct timer_node *current = link_clear(\u0026T-\u003et[level][idx]); 104 \u003e while (current) { 105 \u003e \u003e struct timer_node *temp=current-\u003enext; 106 \u003e \u003e add_node(T,current); 107 \u003e \u003e current=temp; 108 \u003e } 109 } 111 static void 112 timer_shift(struct timer *T) { 113 \u003e int mask = TIME_NEAR; 114 \u003e uint32_t ct = ++T-\u003etime; 115 \u003e if (ct == 0) { 116 \u003e \u003e move_list(T, 3, 0); 117 \u003e } else { 118 \u003e \u003e uint32_t time = ct \u003e\u003e TIME_NEAR_SHIFT; 119 \u003e \u003e int i=0; 120 121 \u003e \u003e while ((ct \u0026 (mask-1))==0","date":"2023-11-14","objectID":"/posts/skynet/skynet_timer/:0:0","series":null,"tags":null,"title":"skynet的定时器","uri":"/posts/skynet/skynet_timer/#定时器执行"},{"categories":["skynet相关"],"content":"\r主要结构 17 #define TIME_NEAR_SHIFT 8 18 #define TIME_NEAR (1 \u003c\u003c TIME_NEAR_SHIFT) 19 #define TIME_LEVEL_SHIFT 6 20 #define TIME_LEVEL (1 \u003c\u003c TIME_LEVEL_SHIFT) 21 #define TIME_NEAR_MASK (TIME_NEAR-1) 22 #define TIME_LEVEL_MASK (TIME_LEVEL-1) 23 24 struct timer_event { 25 \u003e uint32_t handle; 26 \u003e int session; 27 }; 28 29 struct timer_node { 30 \u003e struct timer_node *next; 31 \u003e uint32_t expire; 32 }; 33 34 struct link_list { 35 \u003e struct timer_node head; 36 \u003e struct timer_node *tail; 37 }; 38 39 struct timer { 40 \u003e struct link_list near[TIME_NEAR]; //到期时间较近定时器事件链表 41 \u003e struct link_list t[4][TIME_LEVEL]; //定时器事件链表 42 \u003e struct spinlock lock; //自旋锁 43 \u003e uint32_t time; //启动后tick的时间 44 \u003e uint32_t starttime; //启动时的系统时间 45 \u003e uint64_t current; //skynet自己计算出的实际时间 46 \u003e uint64_t current_point; // 47 }; skynet定时器的基本思想就是把到期时间较近的事件放到near数组中，其余的放到t数值中，每次tick后就从near数组中找到到期的事件触发 定时事件插入 67 static void 68 add_node(struct timer *T,struct timer_node *node) { 69 \u003e uint32_t time=node-\u003eexpire; 70 \u003e uint32_t current_time=T-\u003etime; 71 \u003e 72 \u003e if ((time|TIME_NEAR_MASK)==(current_time|TIME_NEAR_MASK)) { 73 \u003e \u003e link(\u0026T-\u003enear[time\u0026TIME_NEAR_MASK],node); 74 \u003e } else { 75 \u003e \u003e int i; 76 \u003e \u003e uint32_t mask=TIME_NEAR \u003c\u003c TIME_LEVEL_SHIFT; 77 \u003e \u003e for (i=0;i\u003c3;i++) { 78 \u003e \u003e \u003e if ((time|(mask-1))==(current_time|(mask-1))) { 79 \u003e \u003e \u003e \u003e break; 80 \u003e \u003e \u003e } 81 \u003e \u003e \u003e mask \u003c\u003c= TIME_LEVEL_SHIFT; 82 \u003e \u003e } 83 84 \u003e \u003e link(\u0026T-\u003et[i][((time\u003e\u003e(TIME_NEAR_SHIFT + i*TIME_LEVEL_SHIFT)) \u0026 TIME_LEVEL_MASK)],node);\u003e 85 \u003e } 86 } add_node函数可以看出定时事件是怎么分布到near和t数组的 time可以理解为到期时间，current_time可以理解为现在的时间 这里假设 ​ current_time二进制表示为 100000 | 010000 | 001000 | 000100 | 00000010 ​ t1二进制表示为 100000 | 010000 | 001000 | 000100 | 00000011 ​ t2二进制表示为 100000 | 010000 | 001000 | 000101 | 00000010 ​ t3二进制表示为 100000 | 010000 | 001001 | 000100 | 00000010 ​ t4二进制表示为 100000 | 010001 | 001000 | 000100 | 00000010 ​ t5二进制表示为 100001 | 010000 | 001000 | 000100 | 00000010 72 ~ 73： ​ 将time和current_time第9~32位都相同的事件放到near[x]，x是time的第1~8位表示的数值（当time=t1时，t1放到near[3]中，因为t1第1~8位 00000011即为3） 76 ~ 82： ​ 将time和current_time第15~32相同，但第9~14位不相同的到期事件放到t[0][x]数组中，x是time的第9~14位表示的数值（当time=t2时，t2放到t[0][5]，因为t2第9~14位 000101 即为5） ​ 将time和current_time第21~32相同，但第15~20位不相同的到期事件放到t[1][x]数组中，x是time的第15~20位表示的数值（当time=t3时，t3放到t[0][9]，因为t2第9~14位 001001 即为9） ​ 将time和current_time第27~32相同，但第21~26位不相同的到期事件放到t[2][x]数组中，x是time的第21~26位表示的数值（当time=t4时，t4放到t[0][17]，因为t2第9~14位 010001 即为17） ​ 将time和current_time27~32位不相同的到期事件放到t[3][x]数组中，x是time的第27~32位表示的数值（当time=t5时，t5放到t[0][33]，因为t2第9~14位 100001 即为33） 大致上看当current_time为100000 | 010000 | 001000 | 000100 | xxxxxxxx时： ​ 100000 | 010000 | 001000 | 000100 | xxxxxxxx 放到 near中 ​ 100000 | 010000 | 001000 | xxxxxx | xxxxxxxx 放到t[0]中 ​ 100000 | 010000 | xxxxxx | xxxxxx | xxxxxxxx 放到t[1]中 ​ 100000 | xxxxxx | xxxxxx | xxxxxx | xxxxxxxx 放到t[2]中 ​ xxxxxx| xxxxxx| xxxxxx | xxxxxx | xxxxxxxx 放到t[3]中 需要注意的是，并不是说和current_time接近的time就一定会在near中，因为near只包含第9~32位都相同的情况 ​ 一个比较极端的情况是当current_time为 000000 | 111111 | 111111 | 111111 | 11111111 ​ 此时插入与其相差为1的time（000001 | 000000 | 000000 | 000000 | 00000000），是放在t[3][1]中 定时器执行 152 static inline void 153 timer_execute(struct timer *T) { 154 \u003e int idx = T-\u003etime \u0026 TIME_NEAR_MASK; 155 \u003e 156 \u003e while (T-\u003enear[idx].head.next) { 157 \u003e \u003e struct timer_node *current = link_clear(\u0026T-\u003enear[idx]); 158 \u003e \u003e SPIN_UNLOCK(T); 159 \u003e \u003e // dispatch_list don't need lock T 160 \u003e \u003e dispatch_list(current); 161 \u003e \u003e SPIN_LOCK(T); 162 \u003e } 163 } ​ 因为最近的事件都在near上，只需要根据idx就能找到到期的事件 到期事件再分配 101 static void 102 move_list(struct timer *T, int level, int idx) { 103 \u003e struct timer_node *current = link_clear(\u0026T-\u003et[level][idx]); 104 \u003e while (current) { 105 \u003e \u003e struct timer_node *temp=current-\u003enext; 106 \u003e \u003e add_node(T,current); 107 \u003e \u003e current=temp; 108 \u003e } 109 } 111 static void 112 timer_shift(struct timer *T) { 113 \u003e int mask = TIME_NEAR; 114 \u003e uint32_t ct = ++T-\u003etime; 115 \u003e if (ct == 0) { 116 \u003e \u003e move_list(T, 3, 0); 117 \u003e } else { 118 \u003e \u003e uint32_t time = ct \u003e\u003e TIME_NEAR_SHIFT; 119 \u003e \u003e int i=0; 120 121 \u003e \u003e while ((ct \u0026 (mask-1))==0","date":"2023-11-14","objectID":"/posts/skynet/skynet_timer/:0:0","series":null,"tags":null,"title":"skynet的定时器","uri":"/posts/skynet/skynet_timer/#到期事件再分配"},{"categories":["skynet相关"],"content":"\r主要结构 17 #define TIME_NEAR_SHIFT 8 18 #define TIME_NEAR (1 \u003c\u003c TIME_NEAR_SHIFT) 19 #define TIME_LEVEL_SHIFT 6 20 #define TIME_LEVEL (1 \u003c\u003c TIME_LEVEL_SHIFT) 21 #define TIME_NEAR_MASK (TIME_NEAR-1) 22 #define TIME_LEVEL_MASK (TIME_LEVEL-1) 23 24 struct timer_event { 25 \u003e uint32_t handle; 26 \u003e int session; 27 }; 28 29 struct timer_node { 30 \u003e struct timer_node *next; 31 \u003e uint32_t expire; 32 }; 33 34 struct link_list { 35 \u003e struct timer_node head; 36 \u003e struct timer_node *tail; 37 }; 38 39 struct timer { 40 \u003e struct link_list near[TIME_NEAR]; //到期时间较近定时器事件链表 41 \u003e struct link_list t[4][TIME_LEVEL]; //定时器事件链表 42 \u003e struct spinlock lock; //自旋锁 43 \u003e uint32_t time; //启动后tick的时间 44 \u003e uint32_t starttime; //启动时的系统时间 45 \u003e uint64_t current; //skynet自己计算出的实际时间 46 \u003e uint64_t current_point; // 47 }; skynet定时器的基本思想就是把到期时间较近的事件放到near数组中，其余的放到t数值中，每次tick后就从near数组中找到到期的事件触发 定时事件插入 67 static void 68 add_node(struct timer *T,struct timer_node *node) { 69 \u003e uint32_t time=node-\u003eexpire; 70 \u003e uint32_t current_time=T-\u003etime; 71 \u003e 72 \u003e if ((time|TIME_NEAR_MASK)==(current_time|TIME_NEAR_MASK)) { 73 \u003e \u003e link(\u0026T-\u003enear[time\u0026TIME_NEAR_MASK],node); 74 \u003e } else { 75 \u003e \u003e int i; 76 \u003e \u003e uint32_t mask=TIME_NEAR \u003c\u003c TIME_LEVEL_SHIFT; 77 \u003e \u003e for (i=0;i\u003c3;i++) { 78 \u003e \u003e \u003e if ((time|(mask-1))==(current_time|(mask-1))) { 79 \u003e \u003e \u003e \u003e break; 80 \u003e \u003e \u003e } 81 \u003e \u003e \u003e mask \u003c\u003c= TIME_LEVEL_SHIFT; 82 \u003e \u003e } 83 84 \u003e \u003e link(\u0026T-\u003et[i][((time\u003e\u003e(TIME_NEAR_SHIFT + i*TIME_LEVEL_SHIFT)) \u0026 TIME_LEVEL_MASK)],node);\u003e 85 \u003e } 86 } add_node函数可以看出定时事件是怎么分布到near和t数组的 time可以理解为到期时间，current_time可以理解为现在的时间 这里假设 ​ current_time二进制表示为 100000 | 010000 | 001000 | 000100 | 00000010 ​ t1二进制表示为 100000 | 010000 | 001000 | 000100 | 00000011 ​ t2二进制表示为 100000 | 010000 | 001000 | 000101 | 00000010 ​ t3二进制表示为 100000 | 010000 | 001001 | 000100 | 00000010 ​ t4二进制表示为 100000 | 010001 | 001000 | 000100 | 00000010 ​ t5二进制表示为 100001 | 010000 | 001000 | 000100 | 00000010 72 ~ 73： ​ 将time和current_time第9~32位都相同的事件放到near[x]，x是time的第1~8位表示的数值（当time=t1时，t1放到near[3]中，因为t1第1~8位 00000011即为3） 76 ~ 82： ​ 将time和current_time第15~32相同，但第9~14位不相同的到期事件放到t[0][x]数组中，x是time的第9~14位表示的数值（当time=t2时，t2放到t[0][5]，因为t2第9~14位 000101 即为5） ​ 将time和current_time第21~32相同，但第15~20位不相同的到期事件放到t[1][x]数组中，x是time的第15~20位表示的数值（当time=t3时，t3放到t[0][9]，因为t2第9~14位 001001 即为9） ​ 将time和current_time第27~32相同，但第21~26位不相同的到期事件放到t[2][x]数组中，x是time的第21~26位表示的数值（当time=t4时，t4放到t[0][17]，因为t2第9~14位 010001 即为17） ​ 将time和current_time27~32位不相同的到期事件放到t[3][x]数组中，x是time的第27~32位表示的数值（当time=t5时，t5放到t[0][33]，因为t2第9~14位 100001 即为33） 大致上看当current_time为100000 | 010000 | 001000 | 000100 | xxxxxxxx时： ​ 100000 | 010000 | 001000 | 000100 | xxxxxxxx 放到 near中 ​ 100000 | 010000 | 001000 | xxxxxx | xxxxxxxx 放到t[0]中 ​ 100000 | 010000 | xxxxxx | xxxxxx | xxxxxxxx 放到t[1]中 ​ 100000 | xxxxxx | xxxxxx | xxxxxx | xxxxxxxx 放到t[2]中 ​ xxxxxx| xxxxxx| xxxxxx | xxxxxx | xxxxxxxx 放到t[3]中 需要注意的是，并不是说和current_time接近的time就一定会在near中，因为near只包含第9~32位都相同的情况 ​ 一个比较极端的情况是当current_time为 000000 | 111111 | 111111 | 111111 | 11111111 ​ 此时插入与其相差为1的time（000001 | 000000 | 000000 | 000000 | 00000000），是放在t[3][1]中 定时器执行 152 static inline void 153 timer_execute(struct timer *T) { 154 \u003e int idx = T-\u003etime \u0026 TIME_NEAR_MASK; 155 \u003e 156 \u003e while (T-\u003enear[idx].head.next) { 157 \u003e \u003e struct timer_node *current = link_clear(\u0026T-\u003enear[idx]); 158 \u003e \u003e SPIN_UNLOCK(T); 159 \u003e \u003e // dispatch_list don't need lock T 160 \u003e \u003e dispatch_list(current); 161 \u003e \u003e SPIN_LOCK(T); 162 \u003e } 163 } ​ 因为最近的事件都在near上，只需要根据idx就能找到到期的事件 到期事件再分配 101 static void 102 move_list(struct timer *T, int level, int idx) { 103 \u003e struct timer_node *current = link_clear(\u0026T-\u003et[level][idx]); 104 \u003e while (current) { 105 \u003e \u003e struct timer_node *temp=current-\u003enext; 106 \u003e \u003e add_node(T,current); 107 \u003e \u003e current=temp; 108 \u003e } 109 } 111 static void 112 timer_shift(struct timer *T) { 113 \u003e int mask = TIME_NEAR; 114 \u003e uint32_t ct = ++T-\u003etime; 115 \u003e if (ct == 0) { 116 \u003e \u003e move_list(T, 3, 0); 117 \u003e } else { 118 \u003e \u003e uint32_t time = ct \u003e\u003e TIME_NEAR_SHIFT; 119 \u003e \u003e int i=0; 120 121 \u003e \u003e while ((ct \u0026 (mask-1))==0","date":"2023-11-14","objectID":"/posts/skynet/skynet_timer/:0:0","series":null,"tags":null,"title":"skynet的定时器","uri":"/posts/skynet/skynet_timer/#tick函数"},{"categories":["skynet相关"],"content":"\rskynet网络模块 115 struct socket_server { 116 volatile uint64_t time; 117 int reserve_fd; // for EMFILE 118 int recvctrl_fd; 119 int sendctrl_fd; 120 int checkctrl; 121 poll_fd event_fd; 122 ATOM_INT alloc_id; 123 int event_n; 124 int event_index; 125 struct socket_object_interface soi; 126 struct event ev[MAX_EVENT]; 127 struct socket slot[MAX_SOCKET]; 128 char buffer[MAX_INFO]; 129 uint8_t udpbuffer[MAX_UDP_PACKAGE]; 130 fd_set rfds; 131 }; skynet启动时会调用struct socket_server * socket_server_create(uint64_t time); 完成static struct socket_server * SOCKET_SERVER的初始化 380 struct socket_server * 381 socket_server_create(uint64_t time) { 382 int i; 383 int fd[2]; 384 poll_fd efd = sp_create(); 385 if (sp_invalid(efd)) { 386 skynet_error(NULL, \"socket-server: create event pool failed.\"); 387 return NULL; 388 } 389 if (pipe(fd)) { 390 sp_release(efd); 391 skynet_error(NULL, \"socket-server: create socket pair failed.\"); 392 return NULL; 393 } 394 if (sp_add(efd, fd[0], NULL)) { 395 // add recvctrl_fd to event poll 396 skynet_error(NULL, \"socket-server: can't add server fd to event pool.\"); 397 close(fd[0]); 398 close(fd[1]); 399 sp_release(efd); 400 return NULL; 401 } 402 403 struct socket_server *ss = MALLOC(sizeof(*ss)); 404 ss-\u003etime = time; 405 ss-\u003eevent_fd = efd; 406 ss-\u003erecvctrl_fd = fd[0]; 407 ss-\u003esendctrl_fd = fd[1]; 408 ss-\u003echeckctrl = 1; 409 ss-\u003ereserve_fd = dup(1); // reserve an extra fd for EMFILE 410 411 for (i=0;i\u003cMAX_SOCKET;i++) { 412 struct socket *s = \u0026ss-\u003eslot[i]; 413 ATOM_INIT(\u0026s-\u003etype, SOCKET_TYPE_INVALID); 414 clear_wb_list(\u0026s-\u003ehigh); 415 clear_wb_list(\u0026s-\u003elow); 416 spinlock_init(\u0026s-\u003edw_lock); 417 } 418 ATOM_INIT(\u0026ss-\u003ealloc_id , 0); 419 ss-\u003eevent_n = 0; 420 ss-\u003eevent_index = 0; 421 memset(\u0026ss-\u003esoi, 0, sizeof(ss-\u003esoi)); 422 FD_ZERO(\u0026ss-\u003erfds); 423 assert(ss-\u003erecvctrl_fd \u003c FD_SETSIZE); 424 425 return ss; 426 } socket_server_create的主要操作： ​ 384：调用epoll_create()创建epoll套接字 ​ 389：调用pipe()创建管道套接字 ​ 394：将389行中创建的管道接收套接字注册到epoll中 ​ 403~409：动态申请socket_server内存并进行一系列赋值 ​ 411~417：MAX_SOCKET值为2^16，struct socket表示单个连接信息，所以单个skynet进程最大接受2^16个连接 skynet的epoll采用阻塞模式，管道用于接受外部信息从而从外部唤醒epoll socket线程函数 63 static void * 64 thread_socket(void *p) { 65 \u003e struct monitor * m = p; 66 \u003e skynet_initthread(THREAD_SOCKET); 67 \u003e for (;;) { 68 \u003e \u003e int r = skynet_socket_poll(); 69 \u003e \u003e if (r==0) 70 \u003e \u003e \u003e break; 71 \u003e \u003e if (r\u003c0) { 72 \u003e \u003e \u003e CHECK_ABORT 73 \u003e \u003e \u003e continue; 74 \u003e \u003e } 75 \u003e \u003e wakeup(m,0); 76 \u003e } 77 \u003e return NULL; 78 } socket poll函数 78 int 79 skynet_socket_poll() { 80 struct socket_server *ss = SOCKET_SERVER; 81 assert(ss); 82 struct socket_message result; 83 int more = 1; 84 int type = socket_server_poll(ss, \u0026result, \u0026more); 85 switch (type) { 86 case SOCKET_EXIT: 87 return 0; 88 case SOCKET_DATA: 89 forward_message(SKYNET_SOCKET_TYPE_DATA, false, \u0026result); 90 break; 91 case SOCKET_CLOSE: 92 forward_message(SKYNET_SOCKET_TYPE_CLOSE, false, \u0026result); 93 break; 94 case SOCKET_OPEN: 95 forward_message(SKYNET_SOCKET_TYPE_CONNECT, true, \u0026result); 96 break; 97 case SOCKET_ERR: 98 forward_message(SKYNET_SOCKET_TYPE_ERROR, true, \u0026result); 99 break; 100 case SOCKET_ACCEPT: 101 forward_message(SKYNET_SOCKET_TYPE_ACCEPT, true, \u0026result); 102 break; 103 case SOCKET_UDP: 104 forward_message(SKYNET_SOCKET_TYPE_UDP, false, \u0026result); 105 break; 106 case SOCKET_WARNING: 107 forward_message(SKYNET_SOCKET_TYPE_WARNING, false, \u0026result); 108 break; 109 default: 110 skynet_error(NULL, \"Unknown socket message type %d.\",type); 111 return -1; 112 } 113 if (more) { 114 return -1; 115 } 116 return 1; 117 } 主要两个函数socket_server_poll和forward_message socket_server_poll：先读取管道里就绪文件操作符，对就绪文件操作符进行对应的事件处理，将对应信息填充到result中，并返回type foward_message：将处理的结果打包成通用的消息push到消息队列中 1671 int 1672 socket_server_poll(struct socket_server *ss, struct socket_message * result, int * more) { 1673 for (;;) { 1674 if (ss-\u003echeckctrl) { 1675 if (has_cmd(ss)) { 1676 int type = ctrl_cmd(ss, result); 1677 if (type != -1) { 1678 clear_closed_event(ss, result, type); 1679 return type; 1680 } else 1681 continue; 16","date":"2023-11-01","objectID":"/posts/skynet/skynet_net/:0:1","series":null,"tags":null,"title":"skynet的网络","uri":"/posts/skynet/skynet_net/#skynet网络模块"},{"categories":["skynet相关"],"content":"\rskynet网络模块 115 struct socket_server { 116 volatile uint64_t time; 117 int reserve_fd; // for EMFILE 118 int recvctrl_fd; 119 int sendctrl_fd; 120 int checkctrl; 121 poll_fd event_fd; 122 ATOM_INT alloc_id; 123 int event_n; 124 int event_index; 125 struct socket_object_interface soi; 126 struct event ev[MAX_EVENT]; 127 struct socket slot[MAX_SOCKET]; 128 char buffer[MAX_INFO]; 129 uint8_t udpbuffer[MAX_UDP_PACKAGE]; 130 fd_set rfds; 131 }; skynet启动时会调用struct socket_server * socket_server_create(uint64_t time); 完成static struct socket_server * SOCKET_SERVER的初始化 380 struct socket_server * 381 socket_server_create(uint64_t time) { 382 int i; 383 int fd[2]; 384 poll_fd efd = sp_create(); 385 if (sp_invalid(efd)) { 386 skynet_error(NULL, \"socket-server: create event pool failed.\"); 387 return NULL; 388 } 389 if (pipe(fd)) { 390 sp_release(efd); 391 skynet_error(NULL, \"socket-server: create socket pair failed.\"); 392 return NULL; 393 } 394 if (sp_add(efd, fd[0], NULL)) { 395 // add recvctrl_fd to event poll 396 skynet_error(NULL, \"socket-server: can't add server fd to event pool.\"); 397 close(fd[0]); 398 close(fd[1]); 399 sp_release(efd); 400 return NULL; 401 } 402 403 struct socket_server *ss = MALLOC(sizeof(*ss)); 404 ss-\u003etime = time; 405 ss-\u003eevent_fd = efd; 406 ss-\u003erecvctrl_fd = fd[0]; 407 ss-\u003esendctrl_fd = fd[1]; 408 ss-\u003echeckctrl = 1; 409 ss-\u003ereserve_fd = dup(1); // reserve an extra fd for EMFILE 410 411 for (i=0;islot[i]; 413 ATOM_INIT(\u0026s-\u003etype, SOCKET_TYPE_INVALID); 414 clear_wb_list(\u0026s-\u003ehigh); 415 clear_wb_list(\u0026s-\u003elow); 416 spinlock_init(\u0026s-\u003edw_lock); 417 } 418 ATOM_INIT(\u0026ss-\u003ealloc_id , 0); 419 ss-\u003eevent_n = 0; 420 ss-\u003eevent_index = 0; 421 memset(\u0026ss-\u003esoi, 0, sizeof(ss-\u003esoi)); 422 FD_ZERO(\u0026ss-\u003erfds); 423 assert(ss-\u003erecvctrl_fd \u003c FD_SETSIZE); 424 425 return ss; 426 } socket_server_create的主要操作： ​ 384：调用epoll_create()创建epoll套接字 ​ 389：调用pipe()创建管道套接字 ​ 394：将389行中创建的管道接收套接字注册到epoll中 ​ 403~409：动态申请socket_server内存并进行一系列赋值 ​ 411~417：MAX_SOCKET值为2^16，struct socket表示单个连接信息，所以单个skynet进程最大接受2^16个连接 skynet的epoll采用阻塞模式，管道用于接受外部信息从而从外部唤醒epoll socket线程函数 63 static void * 64 thread_socket(void *p) { 65 \u003e struct monitor * m = p; 66 \u003e skynet_initthread(THREAD_SOCKET); 67 \u003e for (;;) { 68 \u003e \u003e int r = skynet_socket_poll(); 69 \u003e \u003e if (r==0) 70 \u003e \u003e \u003e break; 71 \u003e \u003e if (r\u003c0) { 72 \u003e \u003e \u003e CHECK_ABORT 73 \u003e \u003e \u003e continue; 74 \u003e \u003e } 75 \u003e \u003e wakeup(m,0); 76 \u003e } 77 \u003e return NULL; 78 } socket poll函数 78 int 79 skynet_socket_poll() { 80 struct socket_server *ss = SOCKET_SERVER; 81 assert(ss); 82 struct socket_message result; 83 int more = 1; 84 int type = socket_server_poll(ss, \u0026result, \u0026more); 85 switch (type) { 86 case SOCKET_EXIT: 87 return 0; 88 case SOCKET_DATA: 89 forward_message(SKYNET_SOCKET_TYPE_DATA, false, \u0026result); 90 break; 91 case SOCKET_CLOSE: 92 forward_message(SKYNET_SOCKET_TYPE_CLOSE, false, \u0026result); 93 break; 94 case SOCKET_OPEN: 95 forward_message(SKYNET_SOCKET_TYPE_CONNECT, true, \u0026result); 96 break; 97 case SOCKET_ERR: 98 forward_message(SKYNET_SOCKET_TYPE_ERROR, true, \u0026result); 99 break; 100 case SOCKET_ACCEPT: 101 forward_message(SKYNET_SOCKET_TYPE_ACCEPT, true, \u0026result); 102 break; 103 case SOCKET_UDP: 104 forward_message(SKYNET_SOCKET_TYPE_UDP, false, \u0026result); 105 break; 106 case SOCKET_WARNING: 107 forward_message(SKYNET_SOCKET_TYPE_WARNING, false, \u0026result); 108 break; 109 default: 110 skynet_error(NULL, \"Unknown socket message type %d.\",type); 111 return -1; 112 } 113 if (more) { 114 return -1; 115 } 116 return 1; 117 } 主要两个函数socket_server_poll和forward_message socket_server_poll：先读取管道里就绪文件操作符，对就绪文件操作符进行对应的事件处理，将对应信息填充到result中，并返回type foward_message：将处理的结果打包成通用的消息push到消息队列中 1671 int 1672 socket_server_poll(struct socket_server *ss, struct socket_message * result, int * more) { 1673 for (;;) { 1674 if (ss-\u003echeckctrl) { 1675 if (has_cmd(ss)) { 1676 int type = ctrl_cmd(ss, result); 1677 if (type != -1) { 1678 clear_closed_event(ss, result, type); 1679 return type; 1680 } else 1681 continue; 16","date":"2023-11-01","objectID":"/posts/skynet/skynet_net/:0:1","series":null,"tags":null,"title":"skynet的网络","uri":"/posts/skynet/skynet_net/#socket线程函数"},{"categories":["skynet相关"],"content":"\rskynet网络模块 115 struct socket_server { 116 volatile uint64_t time; 117 int reserve_fd; // for EMFILE 118 int recvctrl_fd; 119 int sendctrl_fd; 120 int checkctrl; 121 poll_fd event_fd; 122 ATOM_INT alloc_id; 123 int event_n; 124 int event_index; 125 struct socket_object_interface soi; 126 struct event ev[MAX_EVENT]; 127 struct socket slot[MAX_SOCKET]; 128 char buffer[MAX_INFO]; 129 uint8_t udpbuffer[MAX_UDP_PACKAGE]; 130 fd_set rfds; 131 }; skynet启动时会调用struct socket_server * socket_server_create(uint64_t time); 完成static struct socket_server * SOCKET_SERVER的初始化 380 struct socket_server * 381 socket_server_create(uint64_t time) { 382 int i; 383 int fd[2]; 384 poll_fd efd = sp_create(); 385 if (sp_invalid(efd)) { 386 skynet_error(NULL, \"socket-server: create event pool failed.\"); 387 return NULL; 388 } 389 if (pipe(fd)) { 390 sp_release(efd); 391 skynet_error(NULL, \"socket-server: create socket pair failed.\"); 392 return NULL; 393 } 394 if (sp_add(efd, fd[0], NULL)) { 395 // add recvctrl_fd to event poll 396 skynet_error(NULL, \"socket-server: can't add server fd to event pool.\"); 397 close(fd[0]); 398 close(fd[1]); 399 sp_release(efd); 400 return NULL; 401 } 402 403 struct socket_server *ss = MALLOC(sizeof(*ss)); 404 ss-\u003etime = time; 405 ss-\u003eevent_fd = efd; 406 ss-\u003erecvctrl_fd = fd[0]; 407 ss-\u003esendctrl_fd = fd[1]; 408 ss-\u003echeckctrl = 1; 409 ss-\u003ereserve_fd = dup(1); // reserve an extra fd for EMFILE 410 411 for (i=0;islot[i]; 413 ATOM_INIT(\u0026s-\u003etype, SOCKET_TYPE_INVALID); 414 clear_wb_list(\u0026s-\u003ehigh); 415 clear_wb_list(\u0026s-\u003elow); 416 spinlock_init(\u0026s-\u003edw_lock); 417 } 418 ATOM_INIT(\u0026ss-\u003ealloc_id , 0); 419 ss-\u003eevent_n = 0; 420 ss-\u003eevent_index = 0; 421 memset(\u0026ss-\u003esoi, 0, sizeof(ss-\u003esoi)); 422 FD_ZERO(\u0026ss-\u003erfds); 423 assert(ss-\u003erecvctrl_fd \u003c FD_SETSIZE); 424 425 return ss; 426 } socket_server_create的主要操作： ​ 384：调用epoll_create()创建epoll套接字 ​ 389：调用pipe()创建管道套接字 ​ 394：将389行中创建的管道接收套接字注册到epoll中 ​ 403~409：动态申请socket_server内存并进行一系列赋值 ​ 411~417：MAX_SOCKET值为2^16，struct socket表示单个连接信息，所以单个skynet进程最大接受2^16个连接 skynet的epoll采用阻塞模式，管道用于接受外部信息从而从外部唤醒epoll socket线程函数 63 static void * 64 thread_socket(void *p) { 65 \u003e struct monitor * m = p; 66 \u003e skynet_initthread(THREAD_SOCKET); 67 \u003e for (;;) { 68 \u003e \u003e int r = skynet_socket_poll(); 69 \u003e \u003e if (r==0) 70 \u003e \u003e \u003e break; 71 \u003e \u003e if (r\u003c0) { 72 \u003e \u003e \u003e CHECK_ABORT 73 \u003e \u003e \u003e continue; 74 \u003e \u003e } 75 \u003e \u003e wakeup(m,0); 76 \u003e } 77 \u003e return NULL; 78 } socket poll函数 78 int 79 skynet_socket_poll() { 80 struct socket_server *ss = SOCKET_SERVER; 81 assert(ss); 82 struct socket_message result; 83 int more = 1; 84 int type = socket_server_poll(ss, \u0026result, \u0026more); 85 switch (type) { 86 case SOCKET_EXIT: 87 return 0; 88 case SOCKET_DATA: 89 forward_message(SKYNET_SOCKET_TYPE_DATA, false, \u0026result); 90 break; 91 case SOCKET_CLOSE: 92 forward_message(SKYNET_SOCKET_TYPE_CLOSE, false, \u0026result); 93 break; 94 case SOCKET_OPEN: 95 forward_message(SKYNET_SOCKET_TYPE_CONNECT, true, \u0026result); 96 break; 97 case SOCKET_ERR: 98 forward_message(SKYNET_SOCKET_TYPE_ERROR, true, \u0026result); 99 break; 100 case SOCKET_ACCEPT: 101 forward_message(SKYNET_SOCKET_TYPE_ACCEPT, true, \u0026result); 102 break; 103 case SOCKET_UDP: 104 forward_message(SKYNET_SOCKET_TYPE_UDP, false, \u0026result); 105 break; 106 case SOCKET_WARNING: 107 forward_message(SKYNET_SOCKET_TYPE_WARNING, false, \u0026result); 108 break; 109 default: 110 skynet_error(NULL, \"Unknown socket message type %d.\",type); 111 return -1; 112 } 113 if (more) { 114 return -1; 115 } 116 return 1; 117 } 主要两个函数socket_server_poll和forward_message socket_server_poll：先读取管道里就绪文件操作符，对就绪文件操作符进行对应的事件处理，将对应信息填充到result中，并返回type foward_message：将处理的结果打包成通用的消息push到消息队列中 1671 int 1672 socket_server_poll(struct socket_server *ss, struct socket_message * result, int * more) { 1673 for (;;) { 1674 if (ss-\u003echeckctrl) { 1675 if (has_cmd(ss)) { 1676 int type = ctrl_cmd(ss, result); 1677 if (type != -1) { 1678 clear_closed_event(ss, result, type); 1679 return type; 1680 } else 1681 continue; 16","date":"2023-11-01","objectID":"/posts/skynet/skynet_net/:0:1","series":null,"tags":null,"title":"skynet的网络","uri":"/posts/skynet/skynet_net/#socket-poll函数"},{"categories":["skynet相关"],"content":"\rskynet的callback云风的解释[https://blog.codingnow.com/2022/04/lua_binding_callback.html] function skynet.start(start_func) c.callback(skynet.dispatch_message) init_thread = skynet.timeout(0, function() skynet.init_service(start_func) init_thread = nil end) end 97 static int 98 lcallback(lua_State *L) { 99 \u003e struct skynet_context * context = lua_touserdata(L, lua_upvalueindex(1)); 100 \u003e int forward = lua_toboolean(L, 2); 101 \u003e luaL_checktype(L,1,LUA_TFUNCTION); 102 \u003e lua_settop(L,1); 103 \u003e struct callback_context *cb_ctx = (struct callback_context *)lua_newuserdata(L, sizeof(*cb_ctx)); 104 \u003e cb_ctx-\u003eL = lua_newthread(L); 105 \u003e lua_pushcfunction(cb_ctx-\u003eL, traceback); 106 \u003e lua_setuservalue(L, -2); 107 \u003e lua_setfield(L, LUA_REGISTRYINDEX, \"callback_context\"); 108 \u003e lua_xmove(L, cb_ctx-\u003eL, 1); 109 110 \u003e if (forward) { 111 \u003e \u003e skynet_callback(context, cb_ctx, forward_cb); 112 \u003e } else { 113 \u003e \u003e skynet_callback(context, cb_ctx, _cb); 114 \u003e } 115 116 \u003e return 0; 117 } skynet.start中的c.callback()对应c端的lcallback lcallback分析99：lua_upvalueindex(1)获取调用函数的第一个上值，对应skynet.start()中的c，该值是一个userdata 100：获取传入的第二个参数 101：检查传入的第一个参数类型是否是lua的function 102：把堆栈的栈顶设为1，只保留传入的lua function 103：创建一个userdata 104：创建新的lua线程，把该线程对象push到L的栈顶，c端的cb_ctx-\u003eL 指向该对象 105：把traceback push到新线程的栈顶 106：从L的堆栈中弹出新创建的线程对象并将其该设为用户数据（103行创建的）的uservalue 107：将第103行创建的userdata设置为注册表的”callback_context“字段并弹出，此时栈中剩下调用c函数时传入的lua function 108：把传入参数（lua function）从L堆栈弹出并压入cb_ctx-\u003eL的栈中 113：将新创建的线程对象的引用和回调函数注册到context中（后续回调时会用到） ","date":"2023-09-19","objectID":"/posts/skynet/skynet_cb/:0:1","series":null,"tags":null,"title":"skynet的callback","uri":"/posts/skynet/skynet_cb/#skynet的callback"},{"categories":["skynet相关"],"content":"\rskynet的callback云风的解释[https://blog.codingnow.com/2022/04/lua_binding_callback.html] function skynet.start(start_func) c.callback(skynet.dispatch_message) init_thread = skynet.timeout(0, function() skynet.init_service(start_func) init_thread = nil end) end 97 static int 98 lcallback(lua_State *L) { 99 \u003e struct skynet_context * context = lua_touserdata(L, lua_upvalueindex(1)); 100 \u003e int forward = lua_toboolean(L, 2); 101 \u003e luaL_checktype(L,1,LUA_TFUNCTION); 102 \u003e lua_settop(L,1); 103 \u003e struct callback_context *cb_ctx = (struct callback_context *)lua_newuserdata(L, sizeof(*cb_ctx)); 104 \u003e cb_ctx-\u003eL = lua_newthread(L); 105 \u003e lua_pushcfunction(cb_ctx-\u003eL, traceback); 106 \u003e lua_setuservalue(L, -2); 107 \u003e lua_setfield(L, LUA_REGISTRYINDEX, \"callback_context\"); 108 \u003e lua_xmove(L, cb_ctx-\u003eL, 1); 109 110 \u003e if (forward) { 111 \u003e \u003e skynet_callback(context, cb_ctx, forward_cb); 112 \u003e } else { 113 \u003e \u003e skynet_callback(context, cb_ctx, _cb); 114 \u003e } 115 116 \u003e return 0; 117 } skynet.start中的c.callback()对应c端的lcallback lcallback分析99：lua_upvalueindex(1)获取调用函数的第一个上值，对应skynet.start()中的c，该值是一个userdata 100：获取传入的第二个参数 101：检查传入的第一个参数类型是否是lua的function 102：把堆栈的栈顶设为1，只保留传入的lua function 103：创建一个userdata 104：创建新的lua线程，把该线程对象push到L的栈顶，c端的cb_ctx-\u003eL 指向该对象 105：把traceback push到新线程的栈顶 106：从L的堆栈中弹出新创建的线程对象并将其该设为用户数据（103行创建的）的uservalue 107：将第103行创建的userdata设置为注册表的”callback_context“字段并弹出，此时栈中剩下调用c函数时传入的lua function 108：把传入参数（lua function）从L堆栈弹出并压入cb_ctx-\u003eL的栈中 113：将新创建的线程对象的引用和回调函数注册到context中（后续回调时会用到） ","date":"2023-09-19","objectID":"/posts/skynet/skynet_cb/:0:1","series":null,"tags":null,"title":"skynet的callback","uri":"/posts/skynet/skynet_cb/#lcallback分析"},{"categories":["skynet相关"],"content":"\rcallback调用53 static int 54 _cb(struct skynet_context * context, void * ud, int type, int session, uint32_t source, const void * msg, size_t sz) { 55 \u003e struct callback_context *cb_ctx = (struct callback_context *)ud; 56 \u003e lua_State *L = cb_ctx-\u003eL; 57 \u003e int trace = 1; 58 \u003e int r; 59 \u003e lua_pushvalue(L,2); 60 61 \u003e lua_pushinteger(L, type); 62 \u003e lua_pushlightuserdata(L, (void *)msg); 63 \u003e lua_pushinteger(L,sz); 64 \u003e lua_pushinteger(L, session); 65 \u003e lua_pushinteger(L, source); 66 67 \u003e r = lua_pcall(L, 5, 0 , trace); 68 69 \u003e if (r == LUA_OK) { 70 \u003e \u003e return 0; 71 \u003e } 72 \u003e const char * self = skynet_command(context, \"REG\", NULL); 73 \u003e switch (r) { 74 \u003e case LUA_ERRRUN: 75 \u003e \u003e skynet_error(context, \"lua call [%x to %s : %d msgsz = %d] error : \" KRED \"%s\" KNRM, source , self, session, sz, lua_tostring(L,-1)); 76 \u003e \u003e break; 77 \u003e case LUA_ERRMEM: 78 \u003e \u003e skynet_error(context, \"lua memory error : [%x to %s : %d]\", source , self, session); 79 \u003e \u003e break; 80 \u003e case LUA_ERRERR: 81 \u003e \u003e skynet_error(context, \"lua error in error : [%x to %s : %d]\", source , self, session); 82 \u003e \u003e break; 83 \u003e }; 84 85 \u003e lua_pop(L,1); 86 87 \u003e return 0; 88 } _cb分析消息分发到actor时，会调用dispatch_message接口，最后会调用到_cb 55：ud就是lcallback第103所创建的userdata，实际上是注册回调时创建的lua thread对象，回调发生在这个thread中 59：此时cb_cxt-\u003eL的堆栈中有traceback（lcallback第105行）和 传入的lua function（lcallback第108），将lua function的副本压入栈中 61~65：将参数压栈 67：调用lua function（即skynet.dispatch_message） ","date":"2023-09-19","objectID":"/posts/skynet/skynet_cb/:0:2","series":null,"tags":null,"title":"skynet的callback","uri":"/posts/skynet/skynet_cb/#callback调用"},{"categories":["skynet相关"],"content":"\rcallback调用53 static int 54 _cb(struct skynet_context * context, void * ud, int type, int session, uint32_t source, const void * msg, size_t sz) { 55 \u003e struct callback_context *cb_ctx = (struct callback_context *)ud; 56 \u003e lua_State *L = cb_ctx-\u003eL; 57 \u003e int trace = 1; 58 \u003e int r; 59 \u003e lua_pushvalue(L,2); 60 61 \u003e lua_pushinteger(L, type); 62 \u003e lua_pushlightuserdata(L, (void *)msg); 63 \u003e lua_pushinteger(L,sz); 64 \u003e lua_pushinteger(L, session); 65 \u003e lua_pushinteger(L, source); 66 67 \u003e r = lua_pcall(L, 5, 0 , trace); 68 69 \u003e if (r == LUA_OK) { 70 \u003e \u003e return 0; 71 \u003e } 72 \u003e const char * self = skynet_command(context, \"REG\", NULL); 73 \u003e switch (r) { 74 \u003e case LUA_ERRRUN: 75 \u003e \u003e skynet_error(context, \"lua call [%x to %s : %d msgsz = %d] error : \" KRED \"%s\" KNRM, source , self, session, sz, lua_tostring(L,-1)); 76 \u003e \u003e break; 77 \u003e case LUA_ERRMEM: 78 \u003e \u003e skynet_error(context, \"lua memory error : [%x to %s : %d]\", source , self, session); 79 \u003e \u003e break; 80 \u003e case LUA_ERRERR: 81 \u003e \u003e skynet_error(context, \"lua error in error : [%x to %s : %d]\", source , self, session); 82 \u003e \u003e break; 83 \u003e }; 84 85 \u003e lua_pop(L,1); 86 87 \u003e return 0; 88 } _cb分析消息分发到actor时，会调用dispatch_message接口，最后会调用到_cb 55：ud就是lcallback第103所创建的userdata，实际上是注册回调时创建的lua thread对象，回调发生在这个thread中 59：此时cb_cxt-\u003eL的堆栈中有traceback（lcallback第105行）和 传入的lua function（lcallback第108），将lua function的副本压入栈中 61~65：将参数压栈 67：调用lua function（即skynet.dispatch_message） ","date":"2023-09-19","objectID":"/posts/skynet/skynet_cb/:0:2","series":null,"tags":null,"title":"skynet的callback","uri":"/posts/skynet/skynet_cb/#_cb分析"},{"categories":["其他"],"content":" 段表 保存ELF文件各段的基本属性的结构，记录包括段名，段长度，在文件中的偏移量以及读写权限和段的其他属性 代码段 程序源代码编译后的机器指令存放位置，在文件中占用一定大小，该区域通常为只读 数据段（.data段） 保存已经初始化了的全局静态变量和局部静态变量，在文件中占用一定大小 .bss段 存放未初始化的全局变量和局部静态变量，在文件中不占大小（节省磁盘空间），程序运行前才会开辟空间，已经初始化的变量也可能因为编译器的优化而存放在该段（比如初始化值为0），该段大小（所有未初始化的变量总大小）记录在段表里，符号表里会记录各变量的位置 符号表 记录目标文件中所用到的所有符号（包括定义在目标文件中的全局符号，在本目标文件中引用的全局符号，段名，局部符号，行号信息等） 问题：ELF是什么？其大小与程序中全局变量的是否初始化有什么关系ELF为目标文件（linux下），未初始化的全局变量会保存在.bss段，而.bss段在ELF文件中并不占用大小。 ","date":"2021-11-15","objectID":"/posts/other/elf%E6%96%87%E4%BB%B6/:0:0","series":null,"tags":null,"title":"ELF文件","uri":"/posts/other/elf%E6%96%87%E4%BB%B6/#"},{"categories":["其他"],"content":" 段表 保存ELF文件各段的基本属性的结构，记录包括段名，段长度，在文件中的偏移量以及读写权限和段的其他属性 代码段 程序源代码编译后的机器指令存放位置，在文件中占用一定大小，该区域通常为只读 数据段（.data段） 保存已经初始化了的全局静态变量和局部静态变量，在文件中占用一定大小 .bss段 存放未初始化的全局变量和局部静态变量，在文件中不占大小（节省磁盘空间），程序运行前才会开辟空间，已经初始化的变量也可能因为编译器的优化而存放在该段（比如初始化值为0），该段大小（所有未初始化的变量总大小）记录在段表里，符号表里会记录各变量的位置 符号表 记录目标文件中所用到的所有符号（包括定义在目标文件中的全局符号，在本目标文件中引用的全局符号，段名，局部符号，行号信息等） 问题：ELF是什么？其大小与程序中全局变量的是否初始化有什么关系ELF为目标文件（linux下），未初始化的全局变量会保存在.bss段，而.bss段在ELF文件中并不占用大小。 ","date":"2021-11-15","objectID":"/posts/other/elf%E6%96%87%E4%BB%B6/:0:0","series":null,"tags":null,"title":"ELF文件","uri":"/posts/other/elf%E6%96%87%E4%BB%B6/#问题elf是什么其大小与程序中全局变量的是否初始化有什么关系"},{"categories":["其他"],"content":"\rGit配置 设置名称： git config –global user.name “名称” 设置邮箱： git config –global user.email “邮箱” 查看设置： git config –global –list ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#git配置"},{"categories":["其他"],"content":"\rGit配置 设置名称： git config –global user.name “名称” 设置邮箱： git config –global user.email “邮箱” 查看设置： git config –global –list ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#设置名称"},{"categories":["其他"],"content":"\rGit配置 设置名称： git config –global user.name “名称” 设置邮箱： git config –global user.email “邮箱” 查看设置： git config –global –list ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#设置邮箱"},{"categories":["其他"],"content":"\rGit配置 设置名称： git config –global user.name “名称” 设置邮箱： git config –global user.email “邮箱” 查看设置： git config –global –list ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#查看设置"},{"categories":["其他"],"content":"\rGit分支操作 新建分支： git branch 分支名 git checkout -b 分支名 切换分支： git checkout 分支名 删除分支： git branch -D 分支名 合并分支 git merge 分支名 ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#git分支操作"},{"categories":["其他"],"content":"\rGit分支操作 新建分支： git branch 分支名 git checkout -b 分支名 切换分支： git checkout 分支名 删除分支： git branch -D 分支名 合并分支 git merge 分支名 ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#新建分支"},{"categories":["其他"],"content":"\rGit分支操作 新建分支： git branch 分支名 git checkout -b 分支名 切换分支： git checkout 分支名 删除分支： git branch -D 分支名 合并分支 git merge 分支名 ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#切换分支"},{"categories":["其他"],"content":"\rGit分支操作 新建分支： git branch 分支名 git checkout -b 分支名 切换分支： git checkout 分支名 删除分支： git branch -D 分支名 合并分支 git merge 分支名 ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#删除分支"},{"categories":["其他"],"content":"\rGit分支操作 新建分支： git branch 分支名 git checkout -b 分支名 切换分支： git checkout 分支名 删除分支： git branch -D 分支名 合并分支 git merge 分支名 ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#合并分支"},{"categories":["其他"],"content":"\rGit基本工作流程 添加文件到暂存区(staging area)： git add 文件名 将暂存区文件添加到仓库(local repository)中： git commit -m “提交信息” 上传远程代码(remote repository)并合并： git push -u origin 分支名 下载远程代码并合并 git pull ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#git基本工作流程"},{"categories":["其他"],"content":"\rGit基本工作流程 添加文件到暂存区(staging area)： git add 文件名 将暂存区文件添加到仓库(local repository)中： git commit -m “提交信息” 上传远程代码(remote repository)并合并： git push -u origin 分支名 下载远程代码并合并 git pull ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#添加文件到暂存区staging-area"},{"categories":["其他"],"content":"\rGit基本工作流程 添加文件到暂存区(staging area)： git add 文件名 将暂存区文件添加到仓库(local repository)中： git commit -m “提交信息” 上传远程代码(remote repository)并合并： git push -u origin 分支名 下载远程代码并合并 git pull ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#将暂存区文件添加到仓库local-repository中"},{"categories":["其他"],"content":"\rGit基本工作流程 添加文件到暂存区(staging area)： git add 文件名 将暂存区文件添加到仓库(local repository)中： git commit -m “提交信息” 上传远程代码(remote repository)并合并： git push -u origin 分支名 下载远程代码并合并 git pull ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#上传远程代码remote-repository并合并"},{"categories":["其他"],"content":"\rGit基本工作流程 添加文件到暂存区(staging area)： git add 文件名 将暂存区文件添加到仓库(local repository)中： git commit -m “提交信息” 上传远程代码(remote repository)并合并： git push -u origin 分支名 下载远程代码并合并 git pull ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#下载远程代码并合并"},{"categories":["其他"],"content":"\rGit暂存区文件操作 使用暂存区指定文件覆盖工作区对应文件： git checkout 文件名 删除暂存区文件（工作区不做改变）： git rm –cached 文件名 回滚暂存区对应文件到当前版本： git reset HEAD 文件名 ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#git暂存区文件操作"},{"categories":["其他"],"content":"\rGit暂存区文件操作 使用暂存区指定文件覆盖工作区对应文件： git checkout 文件名 删除暂存区文件（工作区不做改变）： git rm –cached 文件名 回滚暂存区对应文件到当前版本： git reset HEAD 文件名 ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#使用暂存区指定文件覆盖工作区对应文件"},{"categories":["其他"],"content":"\rGit暂存区文件操作 使用暂存区指定文件覆盖工作区对应文件： git checkout 文件名 删除暂存区文件（工作区不做改变）： git rm –cached 文件名 回滚暂存区对应文件到当前版本： git reset HEAD 文件名 ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#删除暂存区文件工作区不做改变"},{"categories":["其他"],"content":"\rGit暂存区文件操作 使用暂存区指定文件覆盖工作区对应文件： git checkout 文件名 删除暂存区文件（工作区不做改变）： git rm –cached 文件名 回滚暂存区对应文件到当前版本： git reset HEAD 文件名 ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#回滚暂存区对应文件到当前版本"},{"categories":["其他"],"content":"\rGit远端交互 列出所有remote： git remote -v 添加远端： git remote add xxx 删除远端关联： git remote remove xxx ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#git远端交互"},{"categories":["其他"],"content":"\rGit远端交互 列出所有remote： git remote -v 添加远端： git remote add xxx 删除远端关联： git remote remove xxx ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#列出所有remote"},{"categories":["其他"],"content":"\rGit远端交互 列出所有remote： git remote -v 添加远端： git remote add xxx 删除远端关联： git remote remove xxx ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#添加远端"},{"categories":["其他"],"content":"\rGit远端交互 列出所有remote： git remote -v 添加远端： git remote add xxx 删除远端关联： git remote remove xxx ","date":"2021-10-27","objectID":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"Git基本操作","uri":"/posts/other/git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#删除远端关联"},{"categories":["redis"],"content":"\rredis主从库模式 ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:0:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#redis主从库模式"},{"categories":["redis"],"content":"\rredis高可靠性 高可靠性包含两层含义：数据尽量少丢失，服务尽量少中断 前者使用AOF和RDB可以保证 后者使用主从库模式保证 ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:1:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#redis高可靠性"},{"categories":["redis"],"content":"\r读写分离 读操作：主库、从库都可以接收 写操作：⾸先到主库执⾏，然后，主库将写操作同步给从库 ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:2:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#读写分离"},{"categories":["redis"],"content":"\r一致性问题 redis在主从数据库之间的复制是异步的，这意味着，主数据库执行完客户端请求的命令后会立即将命令发送给请求的客户端，并同步到从数据库，而不会等待从数据库接收到命令后再返回给客户端，因此该情况就会存在一定的数据不一致性风险，也就是redis不保证强一致性，而是通过从库策略追赶与主数据库的数据差异，以保障主从状态一致 ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:3:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#一致性问题"},{"categories":["redis"],"content":"\r全量复制（主从库第一次同步） ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:0:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#全量复制主从库第一次同步"},{"categories":["redis"],"content":"\r同步过程 从库通过replicaof命令，向主库发送psync命令（参数runID为主库id，offset为复制进度） 主库收到psync命令后，返回FULLRESYNC响应命令（参数为主库runID和主库⽬前的复制进度 offset），主从库开始同步 主库执⾏bgsave命令，⽣成RDB⽂件，接着将⽂件发给从库，从库接收文件后清空当前数据库，加载RDB文件 主库同步RDB文件并不会阻塞，会将期间的写请求记录在专⻔的replication buffer 主库完成RDB文件发送后，会把replication buffer中的修改操作发给从库，从库执行这些操作后就完成了数据同步 ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:1:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#同步过程"},{"categories":["redis"],"content":"\r主从级联模式（“主-从-从”模式） 多个从库连接到同一主库，会导致主库压力增大（主要是fork子进程会阻塞主线程，传输RDB文件会占用主库网络带宽），此时可以使用主从级联模式 ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:2:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#主从级联模式主-从-从模式"},{"categories":["redis"],"content":"\rRDB文件是否落盘 Redis在全量复制时，既支持先生成RDB文件，再把RDB文件传给从库，也支持在主库上直接通过socket把数据传给从库，这称为无盘复制 ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:3:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#rdb文件是否落盘"},{"categories":["redis"],"content":"\r基于长连接的命令传播​ 一旦主从库完成全量复制，他们之间会维护一个网络连接，主库通过该连接把接受到的命令操作同步给从库，避免频繁建立连接的开销 ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:0:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#基于长连接的命令传播"},{"categories":["redis"],"content":"\r增量复制 ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:0:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#增量复制"},{"categories":["redis"],"content":"\r使用场景 网络断连或阻塞会导致主从库无法进行命令传播，而重新进行一次全量复制开销过大，此时主从库使用增量复制同步数据 ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:1:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#使用场景"},{"categories":["redis"],"content":"\r同步过程 主从库断开后，主库会把期间收到的写操作命令写入replication buff和repl_backlog_buffer缓冲区中 repl_backlog_buffer是一个环形缓冲区，slave_repl_offset为从库下标，master_repl_offset为主库下标 主从库连接恢复后，从库首先发送psync命令，并把自己当前的slave_repl_offset发给主库 主库把处于master_repl_offset和slave_repl_offset之间的命令操作同步给从库完成同步 ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:2:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#同步过程-1"},{"categories":["redis"],"content":"\rrepl_backlog_buffer缓冲区 由于repl_back_log_buffer是一个环形缓冲区，当主从库读取速度差异过大有可能导致从库未读的操作被主库的新写操作覆盖，造成主从库数据不一致 缓冲空间⼤⼩ = 主库写⼊命令速度 * 操作⼤⼩ - 主从库间 ⽹络传输命令速度 * 操作⼤⼩，实际应用中考虑其他突发情况，通常把这个缓冲空间扩大一倍 可以考虑使用切片集群分担单个主库的请求压力 repl_backlog_buffer是所有从库共享的 ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:3:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#repl_backlog_buffer缓冲区"},{"categories":["redis"],"content":"\r断线重连后同步选择 由于repl_backlog_buffer存在覆盖的情况，重连后主库会根据从库的slave_repl_offset选择全量复制还是增量复制 ","date":"2021-08-10","objectID":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/:4:0","series":null,"tags":null,"title":"Redis主从库数据同步","uri":"/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#断线重连后同步选择"},{"categories":["redis"],"content":"\rAOF日志 ","date":"2021-07-26","objectID":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/:0:0","series":null,"tags":null,"title":"Redis持久化","uri":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/#aof日志"},{"categories":["redis"],"content":"\rAOF日志实现 AOF日志记录的是redis收到的操作命令，以文本形式保存，由主线程写回 AOF日志采用先执⾏命令再记⽇志的方式（为避免额外的检查开销，不阻塞当前写操作） 用AOF方法进行故障恢复时，需要逐一把操作日志都执行一遍 ","date":"2021-07-26","objectID":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/:1:0","series":null,"tags":null,"title":"Redis持久化","uri":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/#aof日志实现"},{"categories":["redis"],"content":"\r三种回写策略 Always，同步写回：每次执行写操作后立马同步将日志写回磁盘 Everysec，每秒写回：先把日志写到AOF文件的内存缓冲区，每隔一秒将缓冲区的内容写回磁盘 No，操作系统控制写回：先把日志写到AOF文件的内存缓冲区，有操作系统决定写回时机 ","date":"2021-07-26","objectID":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/:2:0","series":null,"tags":null,"title":"Redis持久化","uri":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/#三种回写策略"},{"categories":["redis"],"content":"\r三种回写策略的优劣 写回方式 写回时机 优点 缺点 Always 同步写回 可靠度高，数据基本不会丢失 每次写操作都要落盘，性能影响较大 Everysec 每秒写回 性能适中 宕机时丢失1s内的数据 No 系统控制写回 性能好 宕机会丢失较多数据 ","date":"2021-07-26","objectID":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/:3:0","series":null,"tags":null,"title":"Redis持久化","uri":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/#三种回写策略的优劣"},{"categories":["redis"],"content":"\rAOF重写机制 主线程fork重写子进程，子进程将新的内容写到临时文件中 重写并不阻塞主线程，主线程对于新的写入操作，一边将他们累积到内存缓冲中，一边追加到现有的AOF文件中（避免重写时宕机引起数据丢失） 子进程完成重写后发送信号给父进程，父进程接收信号后将内存缓存中的所有内容追加到新的AOF文件中（阻塞） 最后redis原子地用新文件替换旧文件，之后的命令将直接追加到新的AOF文件末尾 ","date":"2021-07-26","objectID":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/:4:0","series":null,"tags":null,"title":"Redis持久化","uri":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/#aof重写机制"},{"categories":["redis"],"content":"\r内存快照 ","date":"2021-07-26","objectID":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/:0:0","series":null,"tags":null,"title":"Redis持久化","uri":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/#内存快照"},{"categories":["redis"],"content":"\rRedis提供了两个命令来⽣成RDB⽂件，分别是save和bgsave save：在主线程中执行，会导致阻塞 bgsave：创建子线程专门用于写入RDB文件，避免主线程阻塞，是redis默认配置 ","date":"2021-07-26","objectID":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/:1:0","series":null,"tags":null,"title":"Redis持久化","uri":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/#redis提供了两个命令来成rdb件分别是save和bgsave"},{"categories":["redis"],"content":"\r快照原理（利用copy-on-write原理） 主线程fork⽣成bgsave⼦进程，两者共享同一物理内存，子线程将redis内存中的数据全量记录到磁盘文件中，该快照文件成为RDB文件 主线程对数据进行写操作时，会将该部分内存复制一份副本（写时复制），主线程可直接修改原来的数据而不用担心子进程的数据污染问题 ","date":"2021-07-26","objectID":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/:2:0","series":null,"tags":null,"title":"Redis持久化","uri":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/#快照原理利用copy-on-write原理"},{"categories":["redis"],"content":"\r快照优劣 优：可以快速恢复数据库（避免了AOF需要顺序，逐一执行命令带来的低效性能的问题） 劣：频繁的快照会造成性能的消耗，主要是将全量数据写入磁盘的消耗和主线程进行fork操作的消耗 ","date":"2021-07-26","objectID":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/:3:0","series":null,"tags":null,"title":"Redis持久化","uri":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/#快照优劣"},{"categories":["redis"],"content":"\r总结 数据不能丢失时，内存快照和AOF的混合使⽤是⼀个很好的选择 如果允许分钟级别的数据丢失，可以只使⽤RDB 如果只⽤AOF，优先使⽤everysec的配置选项，因为它在可靠性和性能之间取了⼀个平衡 ","date":"2021-07-26","objectID":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/:0:0","series":null,"tags":null,"title":"Redis持久化","uri":"/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96/#总结"},{"categories":["其他"],"content":"\rCenos8安装json-c库 先把文件从https://github.com/json-c/json-c克隆到本地目录 进入json-c目录分别执行cmake ./，sudo make install（cmake要先下好） 安装完成后查看一下/usr/local/include目录下是否有json-c目录（没有就是安装的时候没给权限导致复制失败） 查看/usr/local/lib目录或者/usr/local/lib64目录下是否有json-c的动态库文件（没有的话应该时安装有问题） 添加动态路的路径：sudo vim /etc/ld.so.conf添加/usr/local/lib或者/usr/local/lib64（根据上一步的目录） 用 sudo ldconfig更新文件/etc/ld.so.conf的修改生效 使用时要包含json.h头文件，编译时需要加上-ljson-c（我看网上的都是-json的，这个应该是要看动态库的名称确定吧） 安装时遇到的问题 没有安装cmake工具导致执行cmake命令时出现问题（cmake的版本也要确定一下） 使用-json-c编译导致编译失败 make install时没给权限导致install失败（安装时弹了一个error，没仔细看出来） 没有添加动态库的加载路径，导致执行文件时会报错找不到动态库文件，用ldd查看一下是libjson-c.so.5文件没找到，加了路径记得要sudo ldconfig更新一下不然还是不生效的 ","date":"2021-01-26","objectID":"/posts/other/centos8%E5%AE%89%E8%A3%85json-c%E5%BA%93/:0:0","series":null,"tags":null,"title":"CentOS8安装json C库","uri":"/posts/other/centos8%E5%AE%89%E8%A3%85json-c%E5%BA%93/#"},{"categories":["其他"],"content":"\rCenos8安装json-c库 先把文件从https://github.com/json-c/json-c克隆到本地目录 进入json-c目录分别执行cmake ./，sudo make install（cmake要先下好） 安装完成后查看一下/usr/local/include目录下是否有json-c目录（没有就是安装的时候没给权限导致复制失败） 查看/usr/local/lib目录或者/usr/local/lib64目录下是否有json-c的动态库文件（没有的话应该时安装有问题） 添加动态路的路径：sudo vim /etc/ld.so.conf添加/usr/local/lib或者/usr/local/lib64（根据上一步的目录） 用 sudo ldconfig更新文件/etc/ld.so.conf的修改生效 使用时要包含json.h头文件，编译时需要加上-ljson-c（我看网上的都是-json的，这个应该是要看动态库的名称确定吧） 安装时遇到的问题 没有安装cmake工具导致执行cmake命令时出现问题（cmake的版本也要确定一下） 使用-json-c编译导致编译失败 make install时没给权限导致install失败（安装时弹了一个error，没仔细看出来） 没有添加动态库的加载路径，导致执行文件时会报错找不到动态库文件，用ldd查看一下是libjson-c.so.5文件没找到，加了路径记得要sudo ldconfig更新一下不然还是不生效的 ","date":"2021-01-26","objectID":"/posts/other/centos8%E5%AE%89%E8%A3%85json-c%E5%BA%93/:0:0","series":null,"tags":null,"title":"CentOS8安装json C库","uri":"/posts/other/centos8%E5%AE%89%E8%A3%85json-c%E5%BA%93/#cenos8安装json-c库"},{"categories":["其他"],"content":" 命令 含义/用法 start 开始调试,停在第一行代码处 (gdb) start l(list) 查看源代码 (gdb) l \u003cnumber/function\u003e b(breakpoint) 设置断点 (gdb) b \u003c行号/函数名\u003eb … if i == 3：条件断点 info info breakpoints：显示所有断点 info stack：查看堆栈信息 info args：查看当前参数值 info frame：输出栈帧的使用情况 info locals：查看局部变量 s(step) 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数 (gdb) s n(next) 执行一行源程序代码，此行代码中的函数调用也一并执行 (gdb) n r(run) 运行被调试的程序 (gdb) r c(continue) 继续执行被调试程序，直至下一个断点或程序结束 (gdb) c finish 函数结束 p(print) 显示指定变量的值 (gdb) p \u003c变量名\u003e set args name=v 可指定运行时参数。(gdb) set args 10 20 show args 查看运行时参数 q(quit) 退出GDB调试环境 (gdb) q bt(backtrack) 查看函数堆栈 (gdb) bt f(frame) 切换当前栈 (gdb) f \u003c栈序号\u003e u(until) 结束当前循环 (gdb) until set variable 给变量赋值 jump 在源代码的另一段开始运行 delete 删除断点 (gdb) delete \u003c断点号\u003e watch 变量变化时暂停运行 awatch 变量被访问、改变是暂停执行 rwatch 变量被访问时暂停执行 disp(display) 跟踪查看某个变量,每次停下来都显示它的值 k(kill) 终止正在调试的程序 ","date":"2021-01-15","objectID":"/posts/other/gdb%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":null,"title":"GDB基本操作","uri":"/posts/other/gdb%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/#"},{"categories":["其他"],"content":"\r一、阻塞IO（blocking I/O） io两个阶段： 等待数据准备 将数据从内核拷贝到进程中 调用recvfrom后调用进程/线程阻塞直到内核把数据准备好并把数据拷贝到用户内存后，内核返回结果，调用进程/线程的阻塞状态解除，继续运行（阻塞io） 实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的 ","date":"2020-09-03","objectID":"/posts/other/io%E6%A8%A1%E5%9E%8B/:0:0","series":null,"tags":null,"title":"Io模型","uri":"/posts/other/io%E6%A8%A1%E5%9E%8B/#一阻塞ioblocking-io"},{"categories":["其他"],"content":"\r二、非阻塞IO（noblocking I/O） 调用recvfrom后直接返回结果，若内核数据并没有准备好则返回error。 在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有（这种方法会导致cpu占用率大幅上升） 与阻塞io的主要差异是调用接口后立即返回调用结果而不是阻塞调用方直到内核返回结果。 Linux下，可以通过设置socket使其变为non-blocking ","date":"2020-09-03","objectID":"/posts/other/io%E6%A8%A1%E5%9E%8B/:0:0","series":null,"tags":null,"title":"Io模型","uri":"/posts/other/io%E6%A8%A1%E5%9E%8B/#二非阻塞ionoblocking-io"},{"categories":["其他"],"content":"\r三、多路复用IO（IO multiplexing） select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程 当用户进程调用了select，process会阻塞在select上而不是单个io操作上，而同时，kernel会“监视”所有select负责的socket，当任何一个socket的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 ","date":"2020-09-03","objectID":"/posts/other/io%E6%A8%A1%E5%9E%8B/:0:0","series":null,"tags":null,"title":"Io模型","uri":"/posts/other/io%E6%A8%A1%E5%9E%8B/#三多路复用ioio-multiplexing"},{"categories":["其他"],"content":"\r四、异步IO（Asynchronous I/O） 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 真正的异步io（全过程并没有被阻塞，其他四种可能阻塞在数据准备阶段或者数据复制阶段）。 ","date":"2020-09-03","objectID":"/posts/other/io%E6%A8%A1%E5%9E%8B/:0:0","series":null,"tags":null,"title":"Io模型","uri":"/posts/other/io%E6%A8%A1%E5%9E%8B/#四异步ioasynchronous-io"},{"categories":["其他"],"content":"\r信号驱动IO（signal driven I/O， SIGIO） 首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它来读取数据报。无论如何处理SIGIO信号，这种模型的优势在于等待数据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了select的阻塞与轮询，当有活跃套接字时，由注册的handler处理。 阻塞在数据复制阶段。 ","date":"2020-09-03","objectID":"/posts/other/io%E6%A8%A1%E5%9E%8B/:0:0","series":null,"tags":null,"title":"Io模型","uri":"/posts/other/io%E6%A8%A1%E5%9E%8B/#信号驱动iosignal-driven-io-sigio"},{"categories":["其他"],"content":"\r管道(内核管理的一个缓冲区) 匿名管道：通常用于父子进程的通信(通过fork复制父进程的信息，关闭父进程的读（或写）通道和子进程的写（或读）通道从而形成单向通信的通道) 有名管道：通常用于无亲缘关系进程间的通信 四种读写情况 读端不读（fd[0]未关闭），写端一直写 ：直到管道写满数据后，再次write会导致阻塞，直到管道有空位置才写去数据并返回 写端不写（fd[1]未关闭），但是读端一直读（写端不关闭）：管道为空时阻塞读端，直到管道有数据时才读数据并返回（是否阻塞取决于写端计数器是否大于0….） 读端一直读，且fd[0]保持打开，而写端写了一部分数据不写了，并且关闭fd[1]：读取管道所有数据后返回0 读端读了一部分数据，不读了且关闭fd[0]，写端一直在写且f[1]还保持打开状态：一旦读端关闭而进程write时会接受信号SIGPIPE，通常导致进程异常终止 局限性 只支持单向数据流 缓冲区有限，管道只存在于主存中 所传送的是无格式字节流 效率低下（写数据需要读端读取后才返回） 需要注意同步问题？(自带有同步机制) 有名管道：长期存于系统中，使用不当容易出错 ","date":"2020-07-03","objectID":"/posts/other/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/:0:0","series":null,"tags":null,"title":"进程间通讯","uri":"/posts/other/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/#管道内核管理的一个缓冲区"},{"categories":["其他"],"content":"\r消息队列 实际上就是信息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 信息的传递经过四次信息复制：写端-\u003e内核 内核-\u003e读端(消息队列中信息的复制需要额外消耗CPU的时间．不适宜于信息量大或操作频繁的场合) 消息队列克服了信号传递信息少,管道只能承载无格式字节流以及缓冲区大小受限等特点 可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便 ","date":"2020-07-03","objectID":"/posts/other/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/:0:0","series":null,"tags":null,"title":"进程间通讯","uri":"/posts/other/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/#消息队列"},{"categories":["其他"],"content":"\r共享内存 内存共享机制：将进程的虚拟地址空间映射到相同的物理内存中 该做法会引起进程的内存竞争问题 共享内存是最快的IPC(进程间通信)方式 ","date":"2020-07-03","objectID":"/posts/other/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/:0:0","series":null,"tags":null,"title":"进程间通讯","uri":"/posts/other/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/#共享内存"},{"categories":["其他"],"content":"\r信号量 用于实现进程间的互斥同步问题 ","date":"2020-07-03","objectID":"/posts/other/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/:0:0","series":null,"tags":null,"title":"进程间通讯","uri":"/posts/other/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/#信号量"},{"categories":["其他"],"content":"\rsocket 不同主机间进程通信的主要方法 ","date":"2020-07-03","objectID":"/posts/other/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/:0:0","series":null,"tags":null,"title":"进程间通讯","uri":"/posts/other/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF/#socket"}]